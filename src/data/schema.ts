// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "data/schema.proto" (package "eve_multitools.data", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Type ID definition
 * This mirrors the structure of typeIDs.json in the FSD
 *
 * @generated from protobuf message eve_multitools.data.TypeID
 */
export interface TypeID {
    /**
     * @generated from protobuf field: required double base_price = 1
     */
    basePrice: number;
    /**
     * @generated from protobuf field: required double capacity = 2
     */
    capacity: number;
    /**
     * @generated from protobuf field: optional int32 certificate_template = 3
     */
    certificateTemplate?: number;
    /**
     * @generated from protobuf field: optional int32 description_id = 4
     */
    descriptionId?: number;
    /**
     * @generated from protobuf field: repeated int32 designer_ids = 5
     */
    designerIds: number[];
    /**
     * @generated from protobuf field: optional int32 faction_id = 6
     */
    factionId?: number;
    /**
     * @generated from protobuf field: optional int32 graphic_id = 7
     */
    graphicId?: number;
    /**
     * @generated from protobuf field: required int32 group_id = 8
     */
    groupId: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 9
     */
    iconId?: number;
    /**
     * @generated from protobuf field: required bool is_dynamic_type = 10
     */
    isDynamicType: boolean;
    /**
     * @generated from protobuf field: optional int32 isis_group_id = 11
     */
    isisGroupId?: number;
    /**
     * @generated from protobuf field: optional int32 market_group_id = 12
     */
    marketGroupId?: number;
    /**
     * @generated from protobuf field: optional int32 meta_level = 13
     */
    metaLevel?: number;
    /**
     * @generated from protobuf field: required int32 portion_size = 14
     */
    portionSize: number;
    /**
     * @generated from protobuf field: required bool published = 15
     */
    published: boolean;
    /**
     * @generated from protobuf field: optional int32 quote_author_id = 16
     */
    quoteAuthorId?: number;
    /**
     * @generated from protobuf field: optional int32 quote_id = 17
     */
    quoteId?: number;
    /**
     * @generated from protobuf field: optional int32 race_id = 18
     */
    raceId?: number;
    /**
     * @generated from protobuf field: required double radius = 19
     */
    radius: number;
    /**
     * @generated from protobuf field: optional int32 sound_id = 20
     */
    soundId?: number;
    /**
     * @generated from protobuf field: optional int32 tech_level = 21
     */
    techLevel?: number;
    /**
     * @generated from protobuf field: required int32 type_id = 22
     */
    typeId: number;
    /**
     * @generated from protobuf field: required int32 type_name_id = 23
     */
    typeNameId: number;
    /**
     * @generated from protobuf field: optional int32 variation_parent_type_id = 24
     */
    variationParentTypeId?: number;
    /**
     * @generated from protobuf field: required double volume = 25
     */
    volume: number;
    /**
     * @generated from protobuf field: optional int32 wreck_type_id = 26
     */
    wreckTypeId?: number;
}
/**
 * Type dogma definition
 * This mirrors the structure of typeDogma.json in the FSD
 *
 * @generated from protobuf message eve_multitools.data.TypeDogma
 */
export interface TypeDogma {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeDogma.DogmaAttribute dogma_attributes = 1
     */
    dogmaAttributes: TypeDogma_DogmaAttribute[];
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeDogma.DogmaEffect dogma_effects = 2
     */
    dogmaEffects: TypeDogma_DogmaEffect[];
}
/**
 * Dogma attribute definition
 *
 * @generated from protobuf message eve_multitools.data.TypeDogma.DogmaAttribute
 */
export interface TypeDogma_DogmaAttribute {
    /**
     * @generated from protobuf field: required int32 attribute_id = 1
     */
    attributeId: number;
    /**
     * @generated from protobuf field: required double value = 2
     */
    value: number;
}
/**
 * Dogma effect definition
 *
 * @generated from protobuf message eve_multitools.data.TypeDogma.DogmaEffect
 */
export interface TypeDogma_DogmaEffect {
    /**
     * @generated from protobuf field: required int32 effect_id = 1
     */
    effectId: number;
    /**
     * @generated from protobuf field: required bool is_default = 2
     */
    isDefault: boolean;
}
/**
 * Type material definition
 * This mirrors the structure of typeMaterials.json in the FSD
 *
 * @generated from protobuf message eve_multitools.data.TypeMaterial
 */
export interface TypeMaterial {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeMaterial.Material materials = 1
     */
    materials: TypeMaterial_Material[];
}
/**
 * Material definition
 *
 * @generated from protobuf message eve_multitools.data.TypeMaterial.Material
 */
export interface TypeMaterial_Material {
    /**
     * @generated from protobuf field: required int32 material_type_id = 1
     */
    materialTypeId: number;
    /**
     * @generated from protobuf field: required int32 quantity = 2
     */
    quantity: number;
}
/**
 * Collection of all type IDs
 *
 * @generated from protobuf message eve_multitools.data.TypeCollection
 */
export interface TypeCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeCollection.TypeEntry types = 1
     */
    types: TypeCollection_TypeEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeCollection.TypeEntry
 */
export interface TypeCollection_TypeEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.TypeID type_data = 2
     */
    typeData?: TypeID;
}
/**
 * Collection of all type dogma data
 *
 * @generated from protobuf message eve_multitools.data.TypeDogmaCollection
 */
export interface TypeDogmaCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry type_dogmas = 1
     */
    typeDogmas: TypeDogmaCollection_TypeDogmaEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry
 */
export interface TypeDogmaCollection_TypeDogmaEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.TypeDogma type_dogma = 2
     */
    typeDogma?: TypeDogma;
}
/**
 * Collection of all type material data
 *
 * @generated from protobuf message eve_multitools.data.TypeMaterialCollection
 */
export interface TypeMaterialCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry type_materials = 1
     */
    typeMaterials: TypeMaterialCollection_TypeMaterialEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry
 */
export interface TypeMaterialCollection_TypeMaterialEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.TypeMaterial type_material = 2
     */
    typeMaterial?: TypeMaterial;
}
// @generated message type with reflection information, may provide speed optimized methods
class TypeID$Type extends MessageType<TypeID> {
    constructor() {
        super("eve_multitools.data.TypeID", [
            { no: 1, name: "base_price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "capacity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            {
                no: 3,
                name: "certificate_template",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 4, name: "description_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 5,
                name: "designer_ids",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 6, name: "faction_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "graphic_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "is_dynamic_type", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "isis_group_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 12,
                name: "market_group_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 13, name: "meta_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "portion_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "published", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            {
                no: 16,
                name: "quote_author_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 17, name: "quote_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "race_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 20, name: "sound_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "tech_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "type_name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            {
                no: 24,
                name: "variation_parent_type_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 25, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 26, name: "wreck_type_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<TypeID>): TypeID {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.basePrice = 0;
        message.capacity = 0;
        message.designerIds = [];
        message.groupId = 0;
        message.isDynamicType = false;
        message.portionSize = 0;
        message.published = false;
        message.radius = 0;
        message.typeId = 0;
        message.typeNameId = 0;
        message.volume = 0;
        if (value !== undefined) reflectionMergePartial<TypeID>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeID
    ): TypeID {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required double base_price */ 1:
                    message.basePrice = reader.double();
                    break;
                case /* required double capacity */ 2:
                    message.capacity = reader.double();
                    break;
                case /* optional int32 certificate_template */ 3:
                    message.certificateTemplate = reader.int32();
                    break;
                case /* optional int32 description_id */ 4:
                    message.descriptionId = reader.int32();
                    break;
                case /* repeated int32 designer_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.designerIds.push(reader.int32());
                    else message.designerIds.push(reader.int32());
                    break;
                case /* optional int32 faction_id */ 6:
                    message.factionId = reader.int32();
                    break;
                case /* optional int32 graphic_id */ 7:
                    message.graphicId = reader.int32();
                    break;
                case /* required int32 group_id */ 8:
                    message.groupId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 9:
                    message.iconId = reader.int32();
                    break;
                case /* required bool is_dynamic_type */ 10:
                    message.isDynamicType = reader.bool();
                    break;
                case /* optional int32 isis_group_id */ 11:
                    message.isisGroupId = reader.int32();
                    break;
                case /* optional int32 market_group_id */ 12:
                    message.marketGroupId = reader.int32();
                    break;
                case /* optional int32 meta_level */ 13:
                    message.metaLevel = reader.int32();
                    break;
                case /* required int32 portion_size */ 14:
                    message.portionSize = reader.int32();
                    break;
                case /* required bool published */ 15:
                    message.published = reader.bool();
                    break;
                case /* optional int32 quote_author_id */ 16:
                    message.quoteAuthorId = reader.int32();
                    break;
                case /* optional int32 quote_id */ 17:
                    message.quoteId = reader.int32();
                    break;
                case /* optional int32 race_id */ 18:
                    message.raceId = reader.int32();
                    break;
                case /* required double radius */ 19:
                    message.radius = reader.double();
                    break;
                case /* optional int32 sound_id */ 20:
                    message.soundId = reader.int32();
                    break;
                case /* optional int32 tech_level */ 21:
                    message.techLevel = reader.int32();
                    break;
                case /* required int32 type_id */ 22:
                    message.typeId = reader.int32();
                    break;
                case /* required int32 type_name_id */ 23:
                    message.typeNameId = reader.int32();
                    break;
                case /* optional int32 variation_parent_type_id */ 24:
                    message.variationParentTypeId = reader.int32();
                    break;
                case /* required double volume */ 25:
                    message.volume = reader.double();
                    break;
                case /* optional int32 wreck_type_id */ 26:
                    message.wreckTypeId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeID,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required double base_price = 1; */
        if (message.basePrice !== 0) writer.tag(1, WireType.Bit64).double(message.basePrice);
        /* required double capacity = 2; */
        if (message.capacity !== 0) writer.tag(2, WireType.Bit64).double(message.capacity);
        /* optional int32 certificate_template = 3; */
        if (message.certificateTemplate !== undefined)
            writer.tag(3, WireType.Varint).int32(message.certificateTemplate);
        /* optional int32 description_id = 4; */
        if (message.descriptionId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.descriptionId);
        /* repeated int32 designer_ids = 5; */
        for (let i = 0; i < message.designerIds.length; i++)
            writer.tag(5, WireType.Varint).int32(message.designerIds[i]);
        /* optional int32 faction_id = 6; */
        if (message.factionId !== undefined)
            writer.tag(6, WireType.Varint).int32(message.factionId);
        /* optional int32 graphic_id = 7; */
        if (message.graphicId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.graphicId);
        /* required int32 group_id = 8; */
        if (message.groupId !== 0) writer.tag(8, WireType.Varint).int32(message.groupId);
        /* optional int32 icon_id = 9; */
        if (message.iconId !== undefined) writer.tag(9, WireType.Varint).int32(message.iconId);
        /* required bool is_dynamic_type = 10; */
        if (message.isDynamicType !== false)
            writer.tag(10, WireType.Varint).bool(message.isDynamicType);
        /* optional int32 isis_group_id = 11; */
        if (message.isisGroupId !== undefined)
            writer.tag(11, WireType.Varint).int32(message.isisGroupId);
        /* optional int32 market_group_id = 12; */
        if (message.marketGroupId !== undefined)
            writer.tag(12, WireType.Varint).int32(message.marketGroupId);
        /* optional int32 meta_level = 13; */
        if (message.metaLevel !== undefined)
            writer.tag(13, WireType.Varint).int32(message.metaLevel);
        /* required int32 portion_size = 14; */
        if (message.portionSize !== 0) writer.tag(14, WireType.Varint).int32(message.portionSize);
        /* required bool published = 15; */
        if (message.published !== false) writer.tag(15, WireType.Varint).bool(message.published);
        /* optional int32 quote_author_id = 16; */
        if (message.quoteAuthorId !== undefined)
            writer.tag(16, WireType.Varint).int32(message.quoteAuthorId);
        /* optional int32 quote_id = 17; */
        if (message.quoteId !== undefined) writer.tag(17, WireType.Varint).int32(message.quoteId);
        /* optional int32 race_id = 18; */
        if (message.raceId !== undefined) writer.tag(18, WireType.Varint).int32(message.raceId);
        /* required double radius = 19; */
        if (message.radius !== 0) writer.tag(19, WireType.Bit64).double(message.radius);
        /* optional int32 sound_id = 20; */
        if (message.soundId !== undefined) writer.tag(20, WireType.Varint).int32(message.soundId);
        /* optional int32 tech_level = 21; */
        if (message.techLevel !== undefined)
            writer.tag(21, WireType.Varint).int32(message.techLevel);
        /* required int32 type_id = 22; */
        if (message.typeId !== 0) writer.tag(22, WireType.Varint).int32(message.typeId);
        /* required int32 type_name_id = 23; */
        if (message.typeNameId !== 0) writer.tag(23, WireType.Varint).int32(message.typeNameId);
        /* optional int32 variation_parent_type_id = 24; */
        if (message.variationParentTypeId !== undefined)
            writer.tag(24, WireType.Varint).int32(message.variationParentTypeId);
        /* required double volume = 25; */
        if (message.volume !== 0) writer.tag(25, WireType.Bit64).double(message.volume);
        /* optional int32 wreck_type_id = 26; */
        if (message.wreckTypeId !== undefined)
            writer.tag(26, WireType.Varint).int32(message.wreckTypeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeID
 */
export const TypeID = new TypeID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogma$Type extends MessageType<TypeDogma> {
    constructor() {
        super("eve_multitools.data.TypeDogma", [
            {
                no: 1,
                name: "dogma_attributes",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeDogma_DogmaAttribute,
            },
            {
                no: 2,
                name: "dogma_effects",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeDogma_DogmaEffect,
            },
        ]);
    }
    create(value?: PartialMessage<TypeDogma>): TypeDogma {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.dogmaAttributes = [];
        message.dogmaEffects = [];
        if (value !== undefined) reflectionMergePartial<TypeDogma>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogma
    ): TypeDogma {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeDogma.DogmaAttribute dogma_attributes */ 1:
                    message.dogmaAttributes.push(
                        TypeDogma_DogmaAttribute.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                case /* repeated eve_multitools.data.TypeDogma.DogmaEffect dogma_effects */ 2:
                    message.dogmaEffects.push(
                        TypeDogma_DogmaEffect.internalBinaryRead(reader, reader.uint32(), options)
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogma,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeDogma.DogmaAttribute dogma_attributes = 1; */
        for (let i = 0; i < message.dogmaAttributes.length; i++)
            TypeDogma_DogmaAttribute.internalBinaryWrite(
                message.dogmaAttributes[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* repeated eve_multitools.data.TypeDogma.DogmaEffect dogma_effects = 2; */
        for (let i = 0; i < message.dogmaEffects.length; i++)
            TypeDogma_DogmaEffect.internalBinaryWrite(
                message.dogmaEffects[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogma
 */
export const TypeDogma = new TypeDogma$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogma_DogmaAttribute$Type extends MessageType<TypeDogma_DogmaAttribute> {
    constructor() {
        super("eve_multitools.data.TypeDogma.DogmaAttribute", [
            { no: 1, name: "attribute_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
        ]);
    }
    create(value?: PartialMessage<TypeDogma_DogmaAttribute>): TypeDogma_DogmaAttribute {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.attributeId = 0;
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeDogma_DogmaAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogma_DogmaAttribute
    ): TypeDogma_DogmaAttribute {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 attribute_id */ 1:
                    message.attributeId = reader.int32();
                    break;
                case /* required double value */ 2:
                    message.value = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogma_DogmaAttribute,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 attribute_id = 1; */
        if (message.attributeId !== 0) writer.tag(1, WireType.Varint).int32(message.attributeId);
        /* required double value = 2; */
        if (message.value !== 0) writer.tag(2, WireType.Bit64).double(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogma.DogmaAttribute
 */
export const TypeDogma_DogmaAttribute = new TypeDogma_DogmaAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogma_DogmaEffect$Type extends MessageType<TypeDogma_DogmaEffect> {
    constructor() {
        super("eve_multitools.data.TypeDogma.DogmaEffect", [
            { no: 1, name: "effect_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "is_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
        ]);
    }
    create(value?: PartialMessage<TypeDogma_DogmaEffect>): TypeDogma_DogmaEffect {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.effectId = 0;
        message.isDefault = false;
        if (value !== undefined)
            reflectionMergePartial<TypeDogma_DogmaEffect>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogma_DogmaEffect
    ): TypeDogma_DogmaEffect {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 effect_id */ 1:
                    message.effectId = reader.int32();
                    break;
                case /* required bool is_default */ 2:
                    message.isDefault = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogma_DogmaEffect,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 effect_id = 1; */
        if (message.effectId !== 0) writer.tag(1, WireType.Varint).int32(message.effectId);
        /* required bool is_default = 2; */
        if (message.isDefault !== false) writer.tag(2, WireType.Varint).bool(message.isDefault);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogma.DogmaEffect
 */
export const TypeDogma_DogmaEffect = new TypeDogma_DogmaEffect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterial$Type extends MessageType<TypeMaterial> {
    constructor() {
        super("eve_multitools.data.TypeMaterial", [
            {
                no: 1,
                name: "materials",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeMaterial_Material,
            },
        ]);
    }
    create(value?: PartialMessage<TypeMaterial>): TypeMaterial {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.materials = [];
        if (value !== undefined) reflectionMergePartial<TypeMaterial>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeMaterial
    ): TypeMaterial {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeMaterial.Material materials */ 1:
                    message.materials.push(
                        TypeMaterial_Material.internalBinaryRead(reader, reader.uint32(), options)
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeMaterial,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeMaterial.Material materials = 1; */
        for (let i = 0; i < message.materials.length; i++)
            TypeMaterial_Material.internalBinaryWrite(
                message.materials[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterial
 */
export const TypeMaterial = new TypeMaterial$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterial_Material$Type extends MessageType<TypeMaterial_Material> {
    constructor() {
        super("eve_multitools.data.TypeMaterial.Material", [
            { no: 1, name: "material_type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<TypeMaterial_Material>): TypeMaterial_Material {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.materialTypeId = 0;
        message.quantity = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeMaterial_Material>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeMaterial_Material
    ): TypeMaterial_Material {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 material_type_id */ 1:
                    message.materialTypeId = reader.int32();
                    break;
                case /* required int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeMaterial_Material,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 material_type_id = 1; */
        if (message.materialTypeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.materialTypeId);
        /* required int32 quantity = 2; */
        if (message.quantity !== 0) writer.tag(2, WireType.Varint).int32(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterial.Material
 */
export const TypeMaterial_Material = new TypeMaterial_Material$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeCollection$Type extends MessageType<TypeCollection> {
    constructor() {
        super("eve_multitools.data.TypeCollection", [
            {
                no: 1,
                name: "types",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeCollection_TypeEntry,
            },
        ]);
    }
    create(value?: PartialMessage<TypeCollection>): TypeCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.types = [];
        if (value !== undefined) reflectionMergePartial<TypeCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeCollection
    ): TypeCollection {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeCollection.TypeEntry types */ 1:
                    message.types.push(
                        TypeCollection_TypeEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeCollection.TypeEntry types = 1; */
        for (let i = 0; i < message.types.length; i++)
            TypeCollection_TypeEntry.internalBinaryWrite(
                message.types[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeCollection
 */
export const TypeCollection = new TypeCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeCollection_TypeEntry$Type extends MessageType<TypeCollection_TypeEntry> {
    constructor() {
        super("eve_multitools.data.TypeCollection.TypeEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_data", kind: "message", T: () => TypeID },
        ]);
    }
    create(value?: PartialMessage<TypeCollection_TypeEntry>): TypeCollection_TypeEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeCollection_TypeEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeCollection_TypeEntry
    ): TypeCollection_TypeEntry {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.TypeID type_data */ 2:
                    message.typeData = TypeID.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.typeData
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeCollection_TypeEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0) writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.TypeID type_data = 2; */
        if (message.typeData)
            TypeID.internalBinaryWrite(
                message.typeData,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeCollection.TypeEntry
 */
export const TypeCollection_TypeEntry = new TypeCollection_TypeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogmaCollection$Type extends MessageType<TypeDogmaCollection> {
    constructor() {
        super("eve_multitools.data.TypeDogmaCollection", [
            {
                no: 1,
                name: "type_dogmas",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeDogmaCollection_TypeDogmaEntry,
            },
        ]);
    }
    create(value?: PartialMessage<TypeDogmaCollection>): TypeDogmaCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeDogmas = [];
        if (value !== undefined) reflectionMergePartial<TypeDogmaCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogmaCollection
    ): TypeDogmaCollection {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry type_dogmas */ 1:
                    message.typeDogmas.push(
                        TypeDogmaCollection_TypeDogmaEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogmaCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry type_dogmas = 1; */
        for (let i = 0; i < message.typeDogmas.length; i++)
            TypeDogmaCollection_TypeDogmaEntry.internalBinaryWrite(
                message.typeDogmas[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogmaCollection
 */
export const TypeDogmaCollection = new TypeDogmaCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogmaCollection_TypeDogmaEntry$Type extends MessageType<TypeDogmaCollection_TypeDogmaEntry> {
    constructor() {
        super("eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_dogma", kind: "message", T: () => TypeDogma },
        ]);
    }
    create(
        value?: PartialMessage<TypeDogmaCollection_TypeDogmaEntry>
    ): TypeDogmaCollection_TypeDogmaEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeDogmaCollection_TypeDogmaEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogmaCollection_TypeDogmaEntry
    ): TypeDogmaCollection_TypeDogmaEntry {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.TypeDogma type_dogma */ 2:
                    message.typeDogma = TypeDogma.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.typeDogma
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogmaCollection_TypeDogmaEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0) writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.TypeDogma type_dogma = 2; */
        if (message.typeDogma)
            TypeDogma.internalBinaryWrite(
                message.typeDogma,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry
 */
export const TypeDogmaCollection_TypeDogmaEntry = new TypeDogmaCollection_TypeDogmaEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterialCollection$Type extends MessageType<TypeMaterialCollection> {
    constructor() {
        super("eve_multitools.data.TypeMaterialCollection", [
            {
                no: 1,
                name: "type_materials",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeMaterialCollection_TypeMaterialEntry,
            },
        ]);
    }
    create(value?: PartialMessage<TypeMaterialCollection>): TypeMaterialCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeMaterials = [];
        if (value !== undefined)
            reflectionMergePartial<TypeMaterialCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeMaterialCollection
    ): TypeMaterialCollection {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry type_materials */ 1:
                    message.typeMaterials.push(
                        TypeMaterialCollection_TypeMaterialEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeMaterialCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry type_materials = 1; */
        for (let i = 0; i < message.typeMaterials.length; i++)
            TypeMaterialCollection_TypeMaterialEntry.internalBinaryWrite(
                message.typeMaterials[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterialCollection
 */
export const TypeMaterialCollection = new TypeMaterialCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterialCollection_TypeMaterialEntry$Type extends MessageType<TypeMaterialCollection_TypeMaterialEntry> {
    constructor() {
        super("eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_material", kind: "message", T: () => TypeMaterial },
        ]);
    }
    create(
        value?: PartialMessage<TypeMaterialCollection_TypeMaterialEntry>
    ): TypeMaterialCollection_TypeMaterialEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeMaterialCollection_TypeMaterialEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeMaterialCollection_TypeMaterialEntry
    ): TypeMaterialCollection_TypeMaterialEntry {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.TypeMaterial type_material */ 2:
                    message.typeMaterial = TypeMaterial.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.typeMaterial
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeMaterialCollection_TypeMaterialEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0) writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.TypeMaterial type_material = 2; */
        if (message.typeMaterial)
            TypeMaterial.internalBinaryWrite(
                message.typeMaterial,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry
 */
export const TypeMaterialCollection_TypeMaterialEntry =
    new TypeMaterialCollection_TypeMaterialEntry$Type();
