// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "data/schema.proto" (package "eve_multitools.data", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Type ID definition
 * This mirrors the structure of typeIDs.json in the FSD
 *
 * @generated from protobuf message eve_multitools.data.TypeID
 */
export interface TypeID {
    /**
     * @generated from protobuf field: required double base_price = 1
     */
    basePrice: number;
    /**
     * @generated from protobuf field: required double capacity = 2
     */
    capacity: number;
    /**
     * @generated from protobuf field: optional int32 certificate_template = 3
     */
    certificateTemplate?: number;
    /**
     * @generated from protobuf field: optional int32 description_id = 4
     */
    descriptionId?: number;
    /**
     * @generated from protobuf field: repeated int32 designer_ids = 5
     */
    designerIds: number[];
    /**
     * @generated from protobuf field: optional int32 faction_id = 6
     */
    factionId?: number;
    /**
     * @generated from protobuf field: optional int32 graphic_id = 7
     */
    graphicId?: number;
    /**
     * @generated from protobuf field: required int32 group_id = 8
     */
    groupId: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 9
     */
    iconId?: number;
    /**
     * @generated from protobuf field: required bool is_dynamic_type = 10
     */
    isDynamicType: boolean;
    /**
     * @generated from protobuf field: optional int32 isis_group_id = 11
     */
    isisGroupId?: number;
    /**
     * @generated from protobuf field: optional int32 market_group_id = 12
     */
    marketGroupId?: number;
    /**
     * @generated from protobuf field: optional int32 meta_group_id = 13
     */
    metaGroupId?: number;
    /**
     * @generated from protobuf field: optional int32 meta_level = 14
     */
    metaLevel?: number;
    /**
     * @generated from protobuf field: required int32 portion_size = 15
     */
    portionSize: number;
    /**
     * @generated from protobuf field: required bool published = 16
     */
    published: boolean;
    /**
     * @generated from protobuf field: optional int32 quote_author_id = 17
     */
    quoteAuthorId?: number;
    /**
     * @generated from protobuf field: optional int32 quote_id = 18
     */
    quoteId?: number;
    /**
     * @generated from protobuf field: optional int32 race_id = 19
     */
    raceId?: number;
    /**
     * @generated from protobuf field: required double radius = 20
     */
    radius: number;
    /**
     * @generated from protobuf field: optional int32 sound_id = 21
     */
    soundId?: number;
    /**
     * @generated from protobuf field: optional int32 tech_level = 22
     */
    techLevel?: number;
    /**
     * @generated from protobuf field: required int32 type_id = 23
     */
    typeId: number;
    /**
     * @generated from protobuf field: required int32 type_name_id = 24
     */
    typeNameId: number;
    /**
     * @generated from protobuf field: optional int32 variation_parent_type_id = 25
     */
    variationParentTypeId?: number;
    /**
     * @generated from protobuf field: required double volume = 26
     */
    volume: number;
    /**
     * @generated from protobuf field: optional int32 wreck_type_id = 27
     */
    wreckTypeId?: number;
}
/**
 * Type dogma definition
 * This mirrors the structure of typeDogma.json in the FSD
 *
 * @generated from protobuf message eve_multitools.data.TypeDogma
 */
export interface TypeDogma {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeDogma.DogmaAttribute dogma_attributes = 1
     */
    dogmaAttributes: TypeDogma_DogmaAttribute[];
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeDogma.DogmaEffect dogma_effects = 2
     */
    dogmaEffects: TypeDogma_DogmaEffect[];
}
/**
 * Dogma attribute definition
 *
 * @generated from protobuf message eve_multitools.data.TypeDogma.DogmaAttribute
 */
export interface TypeDogma_DogmaAttribute {
    /**
     * @generated from protobuf field: required int32 attribute_id = 1
     */
    attributeId: number;
    /**
     * @generated from protobuf field: required double value = 2
     */
    value: number;
}
/**
 * Dogma effect definition
 *
 * @generated from protobuf message eve_multitools.data.TypeDogma.DogmaEffect
 */
export interface TypeDogma_DogmaEffect {
    /**
     * @generated from protobuf field: required int32 effect_id = 1
     */
    effectId: number;
    /**
     * @generated from protobuf field: required bool is_default = 2
     */
    isDefault: boolean;
}
/**
 * Type material definition
 * This mirrors the structure of typeMaterials.json in the FSD
 *
 * @generated from protobuf message eve_multitools.data.TypeMaterial
 */
export interface TypeMaterial {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeMaterial.Material materials = 1
     */
    materials: TypeMaterial_Material[];
}
/**
 * Material definition
 *
 * @generated from protobuf message eve_multitools.data.TypeMaterial.Material
 */
export interface TypeMaterial_Material {
    /**
     * @generated from protobuf field: required int32 material_type_id = 1
     */
    materialTypeId: number;
    /**
     * @generated from protobuf field: required int32 quantity = 2
     */
    quantity: number;
}
/**
 * Collection of all type IDs
 *
 * @generated from protobuf message eve_multitools.data.TypeCollection
 */
export interface TypeCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeCollection.TypeEntry types = 1
     */
    types: TypeCollection_TypeEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeCollection.TypeEntry
 */
export interface TypeCollection_TypeEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.TypeID type_data = 2
     */
    typeData?: TypeID;
}
/**
 * Collection of all type dogma data
 *
 * @generated from protobuf message eve_multitools.data.TypeDogmaCollection
 */
export interface TypeDogmaCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry type_dogmas = 1
     */
    typeDogmas: TypeDogmaCollection_TypeDogmaEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry
 */
export interface TypeDogmaCollection_TypeDogmaEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.TypeDogma type_dogma = 2
     */
    typeDogma?: TypeDogma;
}
/**
 * Collection of all type material data
 *
 * @generated from protobuf message eve_multitools.data.TypeMaterialCollection
 */
export interface TypeMaterialCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry type_materials = 1
     */
    typeMaterials: TypeMaterialCollection_TypeMaterialEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry
 */
export interface TypeMaterialCollection_TypeMaterialEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.TypeMaterial type_material = 2
     */
    typeMaterial?: TypeMaterial;
}
/**
 * Category definition
 *
 * @generated from protobuf message eve_multitools.data.Category
 */
export interface Category {
    /**
     * @generated from protobuf field: required int32 category_id = 1
     */
    categoryId: number;
    /**
     * @generated from protobuf field: required int32 category_name_id = 2
     */
    categoryNameId: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 3
     */
    iconId?: number;
    /**
     * @generated from protobuf field: required bool published = 4
     */
    published: boolean;
}
/**
 * Collection of all categories
 *
 * @generated from protobuf message eve_multitools.data.CategoryCollection
 */
export interface CategoryCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.CategoryCollection.CategoryEntry categories = 1
     */
    categories: CategoryCollection_CategoryEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.CategoryCollection.CategoryEntry
 */
export interface CategoryCollection_CategoryEntry {
    /**
     * @generated from protobuf field: required int32 category_id = 1
     */
    categoryId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.Category category_data = 2
     */
    categoryData?: Category;
}
/**
 * Group definition
 *
 * @generated from protobuf message eve_multitools.data.Group
 */
export interface Group {
    /**
     * @generated from protobuf field: required int32 group_id = 1
     */
    groupId: number;
    /**
     * @generated from protobuf field: required int32 group_name_id = 2
     */
    groupNameId: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 3
     */
    iconId?: number;
    /**
     * @generated from protobuf field: required int32 category_id = 4
     */
    categoryId: number;
    /**
     * @generated from protobuf field: required bool anchorable = 5
     */
    anchorable: boolean;
    /**
     * @generated from protobuf field: required bool fittable_non_singleton = 6
     */
    fittableNonSingleton: boolean;
    /**
     * @generated from protobuf field: required bool anchored = 7
     */
    anchored: boolean;
    /**
     * @generated from protobuf field: required bool published = 8
     */
    published: boolean;
    /**
     * @generated from protobuf field: required bool use_base_price = 9
     */
    useBasePrice: boolean;
}
/**
 * Collection of all groups
 *
 * @generated from protobuf message eve_multitools.data.GroupCollection
 */
export interface GroupCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.GroupCollection.GroupEntry groups = 1
     */
    groups: GroupCollection_GroupEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.GroupCollection.GroupEntry
 */
export interface GroupCollection_GroupEntry {
    /**
     * @generated from protobuf field: required int32 group_id = 1
     */
    groupId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.Group group_data = 2
     */
    groupData?: Group;
}
/**
 * MetaGroup definition
 *
 * @generated from protobuf message eve_multitools.data.MetaGroup
 */
export interface MetaGroup {
    /**
     * @generated from protobuf field: required int32 name_id = 1
     */
    nameId: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 2
     */
    iconId?: number;
}
/**
 * Collection of all meta groups
 *
 * @generated from protobuf message eve_multitools.data.MetaGroupCollection
 */
export interface MetaGroupCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.MetaGroupCollection.MetaGroupEntry meta_groups = 1
     */
    metaGroups: MetaGroupCollection_MetaGroupEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.MetaGroupCollection.MetaGroupEntry
 */
export interface MetaGroupCollection_MetaGroupEntry {
    /**
     * @generated from protobuf field: required int32 meta_group_id = 1
     */
    metaGroupId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.MetaGroup meta_group_data = 2
     */
    metaGroupData?: MetaGroup;
}
/**
 * Localization string definition
 *
 * @generated from protobuf message eve_multitools.data.LocalizationString
 */
export interface LocalizationString {
    /**
     * @generated from protobuf field: required string en = 1
     */
    en: string;
    /**
     * @generated from protobuf field: required string zh = 2
     */
    zh: string;
}
/**
 * Collection of all localization strings
 *
 * @generated from protobuf message eve_multitools.data.LocalizationCollection
 */
export interface LocalizationCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.LocalizationCollection.LocalizationEntry localizations = 1
     */
    localizations: LocalizationCollection_LocalizationEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.LocalizationCollection.LocalizationEntry
 */
export interface LocalizationCollection_LocalizationEntry {
    /**
     * @generated from protobuf field: required uint32 key = 1
     */
    key: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.LocalizationString localization_data = 2
     */
    localizationData?: LocalizationString;
}
/**
 * Type localization lookup data
 *
 * @generated from protobuf message eve_multitools.data.TypeLocalizationLookup
 */
export interface TypeLocalizationLookup {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeLocalizationLookup.TypeLocEntry type_entries = 1
     */
    typeEntries: TypeLocalizationLookup_TypeLocEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeLocalizationLookup.TypeLocEntry
 */
export interface TypeLocalizationLookup_TypeLocEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required uint32 type_name_id = 2
     */
    typeNameId: number;
    /**
     * @generated from protobuf field: optional uint32 type_description_id = 3
     */
    typeDescriptionId?: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class TypeID$Type extends MessageType<TypeID> {
    constructor() {
        super("eve_multitools.data.TypeID", [
            { no: 1, name: "base_price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "capacity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "certificate_template", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "description_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "designer_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "faction_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "graphic_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "is_dynamic_type", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "isis_group_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "market_group_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "meta_group_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "meta_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "portion_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "published", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "quote_author_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "quote_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "race_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 21, name: "sound_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "tech_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 24, name: "type_name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 25, name: "variation_parent_type_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 27, name: "wreck_type_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TypeID>): TypeID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.basePrice = 0;
        message.capacity = 0;
        message.designerIds = [];
        message.groupId = 0;
        message.isDynamicType = false;
        message.portionSize = 0;
        message.published = false;
        message.radius = 0;
        message.typeId = 0;
        message.typeNameId = 0;
        message.volume = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeID): TypeID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required double base_price */ 1:
                    message.basePrice = reader.double();
                    break;
                case /* required double capacity */ 2:
                    message.capacity = reader.double();
                    break;
                case /* optional int32 certificate_template */ 3:
                    message.certificateTemplate = reader.int32();
                    break;
                case /* optional int32 description_id */ 4:
                    message.descriptionId = reader.int32();
                    break;
                case /* repeated int32 designer_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.designerIds.push(reader.int32());
                    else
                        message.designerIds.push(reader.int32());
                    break;
                case /* optional int32 faction_id */ 6:
                    message.factionId = reader.int32();
                    break;
                case /* optional int32 graphic_id */ 7:
                    message.graphicId = reader.int32();
                    break;
                case /* required int32 group_id */ 8:
                    message.groupId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 9:
                    message.iconId = reader.int32();
                    break;
                case /* required bool is_dynamic_type */ 10:
                    message.isDynamicType = reader.bool();
                    break;
                case /* optional int32 isis_group_id */ 11:
                    message.isisGroupId = reader.int32();
                    break;
                case /* optional int32 market_group_id */ 12:
                    message.marketGroupId = reader.int32();
                    break;
                case /* optional int32 meta_group_id */ 13:
                    message.metaGroupId = reader.int32();
                    break;
                case /* optional int32 meta_level */ 14:
                    message.metaLevel = reader.int32();
                    break;
                case /* required int32 portion_size */ 15:
                    message.portionSize = reader.int32();
                    break;
                case /* required bool published */ 16:
                    message.published = reader.bool();
                    break;
                case /* optional int32 quote_author_id */ 17:
                    message.quoteAuthorId = reader.int32();
                    break;
                case /* optional int32 quote_id */ 18:
                    message.quoteId = reader.int32();
                    break;
                case /* optional int32 race_id */ 19:
                    message.raceId = reader.int32();
                    break;
                case /* required double radius */ 20:
                    message.radius = reader.double();
                    break;
                case /* optional int32 sound_id */ 21:
                    message.soundId = reader.int32();
                    break;
                case /* optional int32 tech_level */ 22:
                    message.techLevel = reader.int32();
                    break;
                case /* required int32 type_id */ 23:
                    message.typeId = reader.int32();
                    break;
                case /* required int32 type_name_id */ 24:
                    message.typeNameId = reader.int32();
                    break;
                case /* optional int32 variation_parent_type_id */ 25:
                    message.variationParentTypeId = reader.int32();
                    break;
                case /* required double volume */ 26:
                    message.volume = reader.double();
                    break;
                case /* optional int32 wreck_type_id */ 27:
                    message.wreckTypeId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required double base_price = 1; */
        if (message.basePrice !== 0)
            writer.tag(1, WireType.Bit64).double(message.basePrice);
        /* required double capacity = 2; */
        if (message.capacity !== 0)
            writer.tag(2, WireType.Bit64).double(message.capacity);
        /* optional int32 certificate_template = 3; */
        if (message.certificateTemplate !== undefined)
            writer.tag(3, WireType.Varint).int32(message.certificateTemplate);
        /* optional int32 description_id = 4; */
        if (message.descriptionId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.descriptionId);
        /* repeated int32 designer_ids = 5; */
        for (let i = 0; i < message.designerIds.length; i++)
            writer.tag(5, WireType.Varint).int32(message.designerIds[i]);
        /* optional int32 faction_id = 6; */
        if (message.factionId !== undefined)
            writer.tag(6, WireType.Varint).int32(message.factionId);
        /* optional int32 graphic_id = 7; */
        if (message.graphicId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.graphicId);
        /* required int32 group_id = 8; */
        if (message.groupId !== 0)
            writer.tag(8, WireType.Varint).int32(message.groupId);
        /* optional int32 icon_id = 9; */
        if (message.iconId !== undefined)
            writer.tag(9, WireType.Varint).int32(message.iconId);
        /* required bool is_dynamic_type = 10; */
        if (message.isDynamicType !== false)
            writer.tag(10, WireType.Varint).bool(message.isDynamicType);
        /* optional int32 isis_group_id = 11; */
        if (message.isisGroupId !== undefined)
            writer.tag(11, WireType.Varint).int32(message.isisGroupId);
        /* optional int32 market_group_id = 12; */
        if (message.marketGroupId !== undefined)
            writer.tag(12, WireType.Varint).int32(message.marketGroupId);
        /* optional int32 meta_group_id = 13; */
        if (message.metaGroupId !== undefined)
            writer.tag(13, WireType.Varint).int32(message.metaGroupId);
        /* optional int32 meta_level = 14; */
        if (message.metaLevel !== undefined)
            writer.tag(14, WireType.Varint).int32(message.metaLevel);
        /* required int32 portion_size = 15; */
        if (message.portionSize !== 0)
            writer.tag(15, WireType.Varint).int32(message.portionSize);
        /* required bool published = 16; */
        if (message.published !== false)
            writer.tag(16, WireType.Varint).bool(message.published);
        /* optional int32 quote_author_id = 17; */
        if (message.quoteAuthorId !== undefined)
            writer.tag(17, WireType.Varint).int32(message.quoteAuthorId);
        /* optional int32 quote_id = 18; */
        if (message.quoteId !== undefined)
            writer.tag(18, WireType.Varint).int32(message.quoteId);
        /* optional int32 race_id = 19; */
        if (message.raceId !== undefined)
            writer.tag(19, WireType.Varint).int32(message.raceId);
        /* required double radius = 20; */
        if (message.radius !== 0)
            writer.tag(20, WireType.Bit64).double(message.radius);
        /* optional int32 sound_id = 21; */
        if (message.soundId !== undefined)
            writer.tag(21, WireType.Varint).int32(message.soundId);
        /* optional int32 tech_level = 22; */
        if (message.techLevel !== undefined)
            writer.tag(22, WireType.Varint).int32(message.techLevel);
        /* required int32 type_id = 23; */
        if (message.typeId !== 0)
            writer.tag(23, WireType.Varint).int32(message.typeId);
        /* required int32 type_name_id = 24; */
        if (message.typeNameId !== 0)
            writer.tag(24, WireType.Varint).int32(message.typeNameId);
        /* optional int32 variation_parent_type_id = 25; */
        if (message.variationParentTypeId !== undefined)
            writer.tag(25, WireType.Varint).int32(message.variationParentTypeId);
        /* required double volume = 26; */
        if (message.volume !== 0)
            writer.tag(26, WireType.Bit64).double(message.volume);
        /* optional int32 wreck_type_id = 27; */
        if (message.wreckTypeId !== undefined)
            writer.tag(27, WireType.Varint).int32(message.wreckTypeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeID
 */
export const TypeID = new TypeID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogma$Type extends MessageType<TypeDogma> {
    constructor() {
        super("eve_multitools.data.TypeDogma", [
            { no: 1, name: "dogma_attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TypeDogma_DogmaAttribute },
            { no: 2, name: "dogma_effects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TypeDogma_DogmaEffect }
        ]);
    }
    create(value?: PartialMessage<TypeDogma>): TypeDogma {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dogmaAttributes = [];
        message.dogmaEffects = [];
        if (value !== undefined)
            reflectionMergePartial<TypeDogma>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeDogma): TypeDogma {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeDogma.DogmaAttribute dogma_attributes */ 1:
                    message.dogmaAttributes.push(TypeDogma_DogmaAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated eve_multitools.data.TypeDogma.DogmaEffect dogma_effects */ 2:
                    message.dogmaEffects.push(TypeDogma_DogmaEffect.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeDogma, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.TypeDogma.DogmaAttribute dogma_attributes = 1; */
        for (let i = 0; i < message.dogmaAttributes.length; i++)
            TypeDogma_DogmaAttribute.internalBinaryWrite(message.dogmaAttributes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated eve_multitools.data.TypeDogma.DogmaEffect dogma_effects = 2; */
        for (let i = 0; i < message.dogmaEffects.length; i++)
            TypeDogma_DogmaEffect.internalBinaryWrite(message.dogmaEffects[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogma
 */
export const TypeDogma = new TypeDogma$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogma_DogmaAttribute$Type extends MessageType<TypeDogma_DogmaAttribute> {
    constructor() {
        super("eve_multitools.data.TypeDogma.DogmaAttribute", [
            { no: 1, name: "attribute_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<TypeDogma_DogmaAttribute>): TypeDogma_DogmaAttribute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.attributeId = 0;
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeDogma_DogmaAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeDogma_DogmaAttribute): TypeDogma_DogmaAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 attribute_id */ 1:
                    message.attributeId = reader.int32();
                    break;
                case /* required double value */ 2:
                    message.value = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeDogma_DogmaAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 attribute_id = 1; */
        if (message.attributeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.attributeId);
        /* required double value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit64).double(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogma.DogmaAttribute
 */
export const TypeDogma_DogmaAttribute = new TypeDogma_DogmaAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogma_DogmaEffect$Type extends MessageType<TypeDogma_DogmaEffect> {
    constructor() {
        super("eve_multitools.data.TypeDogma.DogmaEffect", [
            { no: 1, name: "effect_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "is_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TypeDogma_DogmaEffect>): TypeDogma_DogmaEffect {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.effectId = 0;
        message.isDefault = false;
        if (value !== undefined)
            reflectionMergePartial<TypeDogma_DogmaEffect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeDogma_DogmaEffect): TypeDogma_DogmaEffect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 effect_id */ 1:
                    message.effectId = reader.int32();
                    break;
                case /* required bool is_default */ 2:
                    message.isDefault = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeDogma_DogmaEffect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 effect_id = 1; */
        if (message.effectId !== 0)
            writer.tag(1, WireType.Varint).int32(message.effectId);
        /* required bool is_default = 2; */
        if (message.isDefault !== false)
            writer.tag(2, WireType.Varint).bool(message.isDefault);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogma.DogmaEffect
 */
export const TypeDogma_DogmaEffect = new TypeDogma_DogmaEffect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterial$Type extends MessageType<TypeMaterial> {
    constructor() {
        super("eve_multitools.data.TypeMaterial", [
            { no: 1, name: "materials", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TypeMaterial_Material }
        ]);
    }
    create(value?: PartialMessage<TypeMaterial>): TypeMaterial {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.materials = [];
        if (value !== undefined)
            reflectionMergePartial<TypeMaterial>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeMaterial): TypeMaterial {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeMaterial.Material materials */ 1:
                    message.materials.push(TypeMaterial_Material.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeMaterial, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.TypeMaterial.Material materials = 1; */
        for (let i = 0; i < message.materials.length; i++)
            TypeMaterial_Material.internalBinaryWrite(message.materials[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterial
 */
export const TypeMaterial = new TypeMaterial$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterial_Material$Type extends MessageType<TypeMaterial_Material> {
    constructor() {
        super("eve_multitools.data.TypeMaterial.Material", [
            { no: 1, name: "material_type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TypeMaterial_Material>): TypeMaterial_Material {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.materialTypeId = 0;
        message.quantity = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeMaterial_Material>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeMaterial_Material): TypeMaterial_Material {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 material_type_id */ 1:
                    message.materialTypeId = reader.int32();
                    break;
                case /* required int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeMaterial_Material, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 material_type_id = 1; */
        if (message.materialTypeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.materialTypeId);
        /* required int32 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterial.Material
 */
export const TypeMaterial_Material = new TypeMaterial_Material$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeCollection$Type extends MessageType<TypeCollection> {
    constructor() {
        super("eve_multitools.data.TypeCollection", [
            { no: 1, name: "types", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TypeCollection_TypeEntry }
        ]);
    }
    create(value?: PartialMessage<TypeCollection>): TypeCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.types = [];
        if (value !== undefined)
            reflectionMergePartial<TypeCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeCollection): TypeCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeCollection.TypeEntry types */ 1:
                    message.types.push(TypeCollection_TypeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.TypeCollection.TypeEntry types = 1; */
        for (let i = 0; i < message.types.length; i++)
            TypeCollection_TypeEntry.internalBinaryWrite(message.types[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeCollection
 */
export const TypeCollection = new TypeCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeCollection_TypeEntry$Type extends MessageType<TypeCollection_TypeEntry> {
    constructor() {
        super("eve_multitools.data.TypeCollection.TypeEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_data", kind: "message", T: () => TypeID }
        ]);
    }
    create(value?: PartialMessage<TypeCollection_TypeEntry>): TypeCollection_TypeEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeCollection_TypeEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeCollection_TypeEntry): TypeCollection_TypeEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.TypeID type_data */ 2:
                    message.typeData = TypeID.internalBinaryRead(reader, reader.uint32(), options, message.typeData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeCollection_TypeEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.TypeID type_data = 2; */
        if (message.typeData)
            TypeID.internalBinaryWrite(message.typeData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeCollection.TypeEntry
 */
export const TypeCollection_TypeEntry = new TypeCollection_TypeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogmaCollection$Type extends MessageType<TypeDogmaCollection> {
    constructor() {
        super("eve_multitools.data.TypeDogmaCollection", [
            { no: 1, name: "type_dogmas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TypeDogmaCollection_TypeDogmaEntry }
        ]);
    }
    create(value?: PartialMessage<TypeDogmaCollection>): TypeDogmaCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeDogmas = [];
        if (value !== undefined)
            reflectionMergePartial<TypeDogmaCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeDogmaCollection): TypeDogmaCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry type_dogmas */ 1:
                    message.typeDogmas.push(TypeDogmaCollection_TypeDogmaEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeDogmaCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry type_dogmas = 1; */
        for (let i = 0; i < message.typeDogmas.length; i++)
            TypeDogmaCollection_TypeDogmaEntry.internalBinaryWrite(message.typeDogmas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogmaCollection
 */
export const TypeDogmaCollection = new TypeDogmaCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogmaCollection_TypeDogmaEntry$Type extends MessageType<TypeDogmaCollection_TypeDogmaEntry> {
    constructor() {
        super("eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_dogma", kind: "message", T: () => TypeDogma }
        ]);
    }
    create(value?: PartialMessage<TypeDogmaCollection_TypeDogmaEntry>): TypeDogmaCollection_TypeDogmaEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeDogmaCollection_TypeDogmaEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeDogmaCollection_TypeDogmaEntry): TypeDogmaCollection_TypeDogmaEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.TypeDogma type_dogma */ 2:
                    message.typeDogma = TypeDogma.internalBinaryRead(reader, reader.uint32(), options, message.typeDogma);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeDogmaCollection_TypeDogmaEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.TypeDogma type_dogma = 2; */
        if (message.typeDogma)
            TypeDogma.internalBinaryWrite(message.typeDogma, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry
 */
export const TypeDogmaCollection_TypeDogmaEntry = new TypeDogmaCollection_TypeDogmaEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterialCollection$Type extends MessageType<TypeMaterialCollection> {
    constructor() {
        super("eve_multitools.data.TypeMaterialCollection", [
            { no: 1, name: "type_materials", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TypeMaterialCollection_TypeMaterialEntry }
        ]);
    }
    create(value?: PartialMessage<TypeMaterialCollection>): TypeMaterialCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeMaterials = [];
        if (value !== undefined)
            reflectionMergePartial<TypeMaterialCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeMaterialCollection): TypeMaterialCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry type_materials */ 1:
                    message.typeMaterials.push(TypeMaterialCollection_TypeMaterialEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeMaterialCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry type_materials = 1; */
        for (let i = 0; i < message.typeMaterials.length; i++)
            TypeMaterialCollection_TypeMaterialEntry.internalBinaryWrite(message.typeMaterials[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterialCollection
 */
export const TypeMaterialCollection = new TypeMaterialCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterialCollection_TypeMaterialEntry$Type extends MessageType<TypeMaterialCollection_TypeMaterialEntry> {
    constructor() {
        super("eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_material", kind: "message", T: () => TypeMaterial }
        ]);
    }
    create(value?: PartialMessage<TypeMaterialCollection_TypeMaterialEntry>): TypeMaterialCollection_TypeMaterialEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeMaterialCollection_TypeMaterialEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeMaterialCollection_TypeMaterialEntry): TypeMaterialCollection_TypeMaterialEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.TypeMaterial type_material */ 2:
                    message.typeMaterial = TypeMaterial.internalBinaryRead(reader, reader.uint32(), options, message.typeMaterial);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeMaterialCollection_TypeMaterialEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.TypeMaterial type_material = 2; */
        if (message.typeMaterial)
            TypeMaterial.internalBinaryWrite(message.typeMaterial, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry
 */
export const TypeMaterialCollection_TypeMaterialEntry = new TypeMaterialCollection_TypeMaterialEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Category$Type extends MessageType<Category> {
    constructor() {
        super("eve_multitools.data.Category", [
            { no: 1, name: "category_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "category_name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "published", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Category>): Category {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.categoryId = 0;
        message.categoryNameId = 0;
        message.published = false;
        if (value !== undefined)
            reflectionMergePartial<Category>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Category): Category {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 category_id */ 1:
                    message.categoryId = reader.int32();
                    break;
                case /* required int32 category_name_id */ 2:
                    message.categoryNameId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 3:
                    message.iconId = reader.int32();
                    break;
                case /* required bool published */ 4:
                    message.published = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Category, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 category_id = 1; */
        if (message.categoryId !== 0)
            writer.tag(1, WireType.Varint).int32(message.categoryId);
        /* required int32 category_name_id = 2; */
        if (message.categoryNameId !== 0)
            writer.tag(2, WireType.Varint).int32(message.categoryNameId);
        /* optional int32 icon_id = 3; */
        if (message.iconId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.iconId);
        /* required bool published = 4; */
        if (message.published !== false)
            writer.tag(4, WireType.Varint).bool(message.published);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Category
 */
export const Category = new Category$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryCollection$Type extends MessageType<CategoryCollection> {
    constructor() {
        super("eve_multitools.data.CategoryCollection", [
            { no: 1, name: "categories", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CategoryCollection_CategoryEntry }
        ]);
    }
    create(value?: PartialMessage<CategoryCollection>): CategoryCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.categories = [];
        if (value !== undefined)
            reflectionMergePartial<CategoryCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CategoryCollection): CategoryCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.CategoryCollection.CategoryEntry categories */ 1:
                    message.categories.push(CategoryCollection_CategoryEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CategoryCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.CategoryCollection.CategoryEntry categories = 1; */
        for (let i = 0; i < message.categories.length; i++)
            CategoryCollection_CategoryEntry.internalBinaryWrite(message.categories[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.CategoryCollection
 */
export const CategoryCollection = new CategoryCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryCollection_CategoryEntry$Type extends MessageType<CategoryCollection_CategoryEntry> {
    constructor() {
        super("eve_multitools.data.CategoryCollection.CategoryEntry", [
            { no: 1, name: "category_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "category_data", kind: "message", T: () => Category }
        ]);
    }
    create(value?: PartialMessage<CategoryCollection_CategoryEntry>): CategoryCollection_CategoryEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.categoryId = 0;
        if (value !== undefined)
            reflectionMergePartial<CategoryCollection_CategoryEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CategoryCollection_CategoryEntry): CategoryCollection_CategoryEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 category_id */ 1:
                    message.categoryId = reader.int32();
                    break;
                case /* required eve_multitools.data.Category category_data */ 2:
                    message.categoryData = Category.internalBinaryRead(reader, reader.uint32(), options, message.categoryData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CategoryCollection_CategoryEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 category_id = 1; */
        if (message.categoryId !== 0)
            writer.tag(1, WireType.Varint).int32(message.categoryId);
        /* required eve_multitools.data.Category category_data = 2; */
        if (message.categoryData)
            Category.internalBinaryWrite(message.categoryData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.CategoryCollection.CategoryEntry
 */
export const CategoryCollection_CategoryEntry = new CategoryCollection_CategoryEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Group$Type extends MessageType<Group> {
    constructor() {
        super("eve_multitools.data.Group", [
            { no: 1, name: "group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "group_name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "category_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "anchorable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "fittable_non_singleton", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "anchored", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "published", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "use_base_price", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Group>): Group {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groupId = 0;
        message.groupNameId = 0;
        message.categoryId = 0;
        message.anchorable = false;
        message.fittableNonSingleton = false;
        message.anchored = false;
        message.published = false;
        message.useBasePrice = false;
        if (value !== undefined)
            reflectionMergePartial<Group>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Group): Group {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 group_id */ 1:
                    message.groupId = reader.int32();
                    break;
                case /* required int32 group_name_id */ 2:
                    message.groupNameId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 3:
                    message.iconId = reader.int32();
                    break;
                case /* required int32 category_id */ 4:
                    message.categoryId = reader.int32();
                    break;
                case /* required bool anchorable */ 5:
                    message.anchorable = reader.bool();
                    break;
                case /* required bool fittable_non_singleton */ 6:
                    message.fittableNonSingleton = reader.bool();
                    break;
                case /* required bool anchored */ 7:
                    message.anchored = reader.bool();
                    break;
                case /* required bool published */ 8:
                    message.published = reader.bool();
                    break;
                case /* required bool use_base_price */ 9:
                    message.useBasePrice = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Group, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 group_id = 1; */
        if (message.groupId !== 0)
            writer.tag(1, WireType.Varint).int32(message.groupId);
        /* required int32 group_name_id = 2; */
        if (message.groupNameId !== 0)
            writer.tag(2, WireType.Varint).int32(message.groupNameId);
        /* optional int32 icon_id = 3; */
        if (message.iconId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.iconId);
        /* required int32 category_id = 4; */
        if (message.categoryId !== 0)
            writer.tag(4, WireType.Varint).int32(message.categoryId);
        /* required bool anchorable = 5; */
        if (message.anchorable !== false)
            writer.tag(5, WireType.Varint).bool(message.anchorable);
        /* required bool fittable_non_singleton = 6; */
        if (message.fittableNonSingleton !== false)
            writer.tag(6, WireType.Varint).bool(message.fittableNonSingleton);
        /* required bool anchored = 7; */
        if (message.anchored !== false)
            writer.tag(7, WireType.Varint).bool(message.anchored);
        /* required bool published = 8; */
        if (message.published !== false)
            writer.tag(8, WireType.Varint).bool(message.published);
        /* required bool use_base_price = 9; */
        if (message.useBasePrice !== false)
            writer.tag(9, WireType.Varint).bool(message.useBasePrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Group
 */
export const Group = new Group$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupCollection$Type extends MessageType<GroupCollection> {
    constructor() {
        super("eve_multitools.data.GroupCollection", [
            { no: 1, name: "groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GroupCollection_GroupEntry }
        ]);
    }
    create(value?: PartialMessage<GroupCollection>): GroupCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groups = [];
        if (value !== undefined)
            reflectionMergePartial<GroupCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupCollection): GroupCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.GroupCollection.GroupEntry groups */ 1:
                    message.groups.push(GroupCollection_GroupEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.GroupCollection.GroupEntry groups = 1; */
        for (let i = 0; i < message.groups.length; i++)
            GroupCollection_GroupEntry.internalBinaryWrite(message.groups[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.GroupCollection
 */
export const GroupCollection = new GroupCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupCollection_GroupEntry$Type extends MessageType<GroupCollection_GroupEntry> {
    constructor() {
        super("eve_multitools.data.GroupCollection.GroupEntry", [
            { no: 1, name: "group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "group_data", kind: "message", T: () => Group }
        ]);
    }
    create(value?: PartialMessage<GroupCollection_GroupEntry>): GroupCollection_GroupEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groupId = 0;
        if (value !== undefined)
            reflectionMergePartial<GroupCollection_GroupEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupCollection_GroupEntry): GroupCollection_GroupEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 group_id */ 1:
                    message.groupId = reader.int32();
                    break;
                case /* required eve_multitools.data.Group group_data */ 2:
                    message.groupData = Group.internalBinaryRead(reader, reader.uint32(), options, message.groupData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupCollection_GroupEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 group_id = 1; */
        if (message.groupId !== 0)
            writer.tag(1, WireType.Varint).int32(message.groupId);
        /* required eve_multitools.data.Group group_data = 2; */
        if (message.groupData)
            Group.internalBinaryWrite(message.groupData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.GroupCollection.GroupEntry
 */
export const GroupCollection_GroupEntry = new GroupCollection_GroupEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetaGroup$Type extends MessageType<MetaGroup> {
    constructor() {
        super("eve_multitools.data.MetaGroup", [
            { no: 1, name: "name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MetaGroup>): MetaGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nameId = 0;
        if (value !== undefined)
            reflectionMergePartial<MetaGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetaGroup): MetaGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 name_id */ 1:
                    message.nameId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 2:
                    message.iconId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetaGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 name_id = 1; */
        if (message.nameId !== 0)
            writer.tag(1, WireType.Varint).int32(message.nameId);
        /* optional int32 icon_id = 2; */
        if (message.iconId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.iconId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.MetaGroup
 */
export const MetaGroup = new MetaGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetaGroupCollection$Type extends MessageType<MetaGroupCollection> {
    constructor() {
        super("eve_multitools.data.MetaGroupCollection", [
            { no: 1, name: "meta_groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MetaGroupCollection_MetaGroupEntry }
        ]);
    }
    create(value?: PartialMessage<MetaGroupCollection>): MetaGroupCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metaGroups = [];
        if (value !== undefined)
            reflectionMergePartial<MetaGroupCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetaGroupCollection): MetaGroupCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.MetaGroupCollection.MetaGroupEntry meta_groups */ 1:
                    message.metaGroups.push(MetaGroupCollection_MetaGroupEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetaGroupCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.MetaGroupCollection.MetaGroupEntry meta_groups = 1; */
        for (let i = 0; i < message.metaGroups.length; i++)
            MetaGroupCollection_MetaGroupEntry.internalBinaryWrite(message.metaGroups[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.MetaGroupCollection
 */
export const MetaGroupCollection = new MetaGroupCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetaGroupCollection_MetaGroupEntry$Type extends MessageType<MetaGroupCollection_MetaGroupEntry> {
    constructor() {
        super("eve_multitools.data.MetaGroupCollection.MetaGroupEntry", [
            { no: 1, name: "meta_group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "meta_group_data", kind: "message", T: () => MetaGroup }
        ]);
    }
    create(value?: PartialMessage<MetaGroupCollection_MetaGroupEntry>): MetaGroupCollection_MetaGroupEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metaGroupId = 0;
        if (value !== undefined)
            reflectionMergePartial<MetaGroupCollection_MetaGroupEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetaGroupCollection_MetaGroupEntry): MetaGroupCollection_MetaGroupEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 meta_group_id */ 1:
                    message.metaGroupId = reader.int32();
                    break;
                case /* required eve_multitools.data.MetaGroup meta_group_data */ 2:
                    message.metaGroupData = MetaGroup.internalBinaryRead(reader, reader.uint32(), options, message.metaGroupData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetaGroupCollection_MetaGroupEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 meta_group_id = 1; */
        if (message.metaGroupId !== 0)
            writer.tag(1, WireType.Varint).int32(message.metaGroupId);
        /* required eve_multitools.data.MetaGroup meta_group_data = 2; */
        if (message.metaGroupData)
            MetaGroup.internalBinaryWrite(message.metaGroupData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.MetaGroupCollection.MetaGroupEntry
 */
export const MetaGroupCollection_MetaGroupEntry = new MetaGroupCollection_MetaGroupEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalizationString$Type extends MessageType<LocalizationString> {
    constructor() {
        super("eve_multitools.data.LocalizationString", [
            { no: 1, name: "en", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "zh", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LocalizationString>): LocalizationString {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.en = "";
        message.zh = "";
        if (value !== undefined)
            reflectionMergePartial<LocalizationString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalizationString): LocalizationString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required string en */ 1:
                    message.en = reader.string();
                    break;
                case /* required string zh */ 2:
                    message.zh = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalizationString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required string en = 1; */
        if (message.en !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.en);
        /* required string zh = 2; */
        if (message.zh !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.zh);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.LocalizationString
 */
export const LocalizationString = new LocalizationString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalizationCollection$Type extends MessageType<LocalizationCollection> {
    constructor() {
        super("eve_multitools.data.LocalizationCollection", [
            { no: 1, name: "localizations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LocalizationCollection_LocalizationEntry }
        ]);
    }
    create(value?: PartialMessage<LocalizationCollection>): LocalizationCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localizations = [];
        if (value !== undefined)
            reflectionMergePartial<LocalizationCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalizationCollection): LocalizationCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.LocalizationCollection.LocalizationEntry localizations */ 1:
                    message.localizations.push(LocalizationCollection_LocalizationEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalizationCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.LocalizationCollection.LocalizationEntry localizations = 1; */
        for (let i = 0; i < message.localizations.length; i++)
            LocalizationCollection_LocalizationEntry.internalBinaryWrite(message.localizations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.LocalizationCollection
 */
export const LocalizationCollection = new LocalizationCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalizationCollection_LocalizationEntry$Type extends MessageType<LocalizationCollection_LocalizationEntry> {
    constructor() {
        super("eve_multitools.data.LocalizationCollection.LocalizationEntry", [
            { no: 1, name: "key", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "localization_data", kind: "message", T: () => LocalizationString }
        ]);
    }
    create(value?: PartialMessage<LocalizationCollection_LocalizationEntry>): LocalizationCollection_LocalizationEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = 0;
        if (value !== undefined)
            reflectionMergePartial<LocalizationCollection_LocalizationEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalizationCollection_LocalizationEntry): LocalizationCollection_LocalizationEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* required eve_multitools.data.LocalizationString localization_data */ 2:
                    message.localizationData = LocalizationString.internalBinaryRead(reader, reader.uint32(), options, message.localizationData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalizationCollection_LocalizationEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required uint32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Varint).uint32(message.key);
        /* required eve_multitools.data.LocalizationString localization_data = 2; */
        if (message.localizationData)
            LocalizationString.internalBinaryWrite(message.localizationData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.LocalizationCollection.LocalizationEntry
 */
export const LocalizationCollection_LocalizationEntry = new LocalizationCollection_LocalizationEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeLocalizationLookup$Type extends MessageType<TypeLocalizationLookup> {
    constructor() {
        super("eve_multitools.data.TypeLocalizationLookup", [
            { no: 1, name: "type_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TypeLocalizationLookup_TypeLocEntry }
        ]);
    }
    create(value?: PartialMessage<TypeLocalizationLookup>): TypeLocalizationLookup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeEntries = [];
        if (value !== undefined)
            reflectionMergePartial<TypeLocalizationLookup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeLocalizationLookup): TypeLocalizationLookup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeLocalizationLookup.TypeLocEntry type_entries */ 1:
                    message.typeEntries.push(TypeLocalizationLookup_TypeLocEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeLocalizationLookup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_multitools.data.TypeLocalizationLookup.TypeLocEntry type_entries = 1; */
        for (let i = 0; i < message.typeEntries.length; i++)
            TypeLocalizationLookup_TypeLocEntry.internalBinaryWrite(message.typeEntries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeLocalizationLookup
 */
export const TypeLocalizationLookup = new TypeLocalizationLookup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeLocalizationLookup_TypeLocEntry$Type extends MessageType<TypeLocalizationLookup_TypeLocEntry> {
    constructor() {
        super("eve_multitools.data.TypeLocalizationLookup.TypeLocEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_name_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "type_description_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TypeLocalizationLookup_TypeLocEntry>): TypeLocalizationLookup_TypeLocEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeId = 0;
        message.typeNameId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeLocalizationLookup_TypeLocEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeLocalizationLookup_TypeLocEntry): TypeLocalizationLookup_TypeLocEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required uint32 type_name_id */ 2:
                    message.typeNameId = reader.uint32();
                    break;
                case /* optional uint32 type_description_id */ 3:
                    message.typeDescriptionId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeLocalizationLookup_TypeLocEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required uint32 type_name_id = 2; */
        if (message.typeNameId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.typeNameId);
        /* optional uint32 type_description_id = 3; */
        if (message.typeDescriptionId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.typeDescriptionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeLocalizationLookup.TypeLocEntry
 */
export const TypeLocalizationLookup_TypeLocEntry = new TypeLocalizationLookup_TypeLocEntry$Type();
