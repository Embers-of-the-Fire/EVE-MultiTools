// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "data/schema.proto" (package "eve_multitools.data", syntax proto2)
// tslint:disable
import type {
    BinaryReadOptions,
    BinaryWriteOptions,
    IBinaryReader,
    IBinaryWriter,
    PartialMessage,
} from "@protobuf-ts/runtime";
import {
    MessageType,
    reflectionMergePartial,
    UnknownFieldHandler,
    WireType,
} from "@protobuf-ts/runtime";
/**
 * Type ID definition
 * This mirrors the structure of typeIDs.json in the FSD
 *
 * @generated from protobuf message eve_multitools.data.TypeID
 */
export interface TypeID {
    /**
     * @generated from protobuf field: required double base_price = 1
     */
    basePrice: number;
    /**
     * @generated from protobuf field: required double capacity = 2
     */
    capacity: number;
    /**
     * @generated from protobuf field: optional int32 certificate_template = 3
     */
    certificateTemplate?: number;
    /**
     * @generated from protobuf field: optional int32 description_id = 4
     */
    descriptionId?: number;
    /**
     * @generated from protobuf field: repeated int32 designer_ids = 5
     */
    designerIds: number[];
    /**
     * @generated from protobuf field: optional int32 faction_id = 6
     */
    factionId?: number;
    /**
     * @generated from protobuf field: optional int32 graphic_id = 7
     */
    graphicId?: number;
    /**
     * @generated from protobuf field: required int32 group_id = 8
     */
    groupId: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 9
     */
    iconId?: number;
    /**
     * @generated from protobuf field: required bool is_dynamic_type = 10
     */
    isDynamicType: boolean;
    /**
     * @generated from protobuf field: optional int32 isis_group_id = 11
     */
    isisGroupId?: number;
    /**
     * @generated from protobuf field: optional int32 market_group_id = 12
     */
    marketGroupId?: number;
    /**
     * @generated from protobuf field: optional int32 meta_group_id = 13
     */
    metaGroupId?: number;
    /**
     * @generated from protobuf field: optional int32 meta_level = 14
     */
    metaLevel?: number;
    /**
     * @generated from protobuf field: required int32 portion_size = 15
     */
    portionSize: number;
    /**
     * @generated from protobuf field: required bool published = 16
     */
    published: boolean;
    /**
     * @generated from protobuf field: optional int32 quote_author_id = 17
     */
    quoteAuthorId?: number;
    /**
     * @generated from protobuf field: optional int32 quote_id = 18
     */
    quoteId?: number;
    /**
     * @generated from protobuf field: optional int32 race_id = 19
     */
    raceId?: number;
    /**
     * @generated from protobuf field: required double radius = 20
     */
    radius: number;
    /**
     * @generated from protobuf field: optional int32 sound_id = 21
     */
    soundId?: number;
    /**
     * @generated from protobuf field: optional int32 tech_level = 22
     */
    techLevel?: number;
    /**
     * @generated from protobuf field: required int32 type_id = 23
     */
    typeId: number;
    /**
     * @generated from protobuf field: required int32 type_name_id = 24
     */
    typeNameId: number;
    /**
     * @generated from protobuf field: optional int32 variation_parent_type_id = 25
     */
    variationParentTypeId?: number;
    /**
     * @generated from protobuf field: required double volume = 26
     */
    volume: number;
    /**
     * @generated from protobuf field: optional int32 wreck_type_id = 27
     */
    wreckTypeId?: number;
}
/**
 * Type dogma definition
 * This mirrors the structure of typeDogma.json in the FSD
 *
 * @generated from protobuf message eve_multitools.data.TypeDogma
 */
export interface TypeDogma {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeDogma.DogmaAttribute dogma_attributes = 1
     */
    dogmaAttributes: TypeDogma_DogmaAttribute[];
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeDogma.DogmaEffect dogma_effects = 2
     */
    dogmaEffects: TypeDogma_DogmaEffect[];
}
/**
 * Dogma attribute definition
 *
 * @generated from protobuf message eve_multitools.data.TypeDogma.DogmaAttribute
 */
export interface TypeDogma_DogmaAttribute {
    /**
     * @generated from protobuf field: required int32 attribute_id = 1
     */
    attributeId: number;
    /**
     * @generated from protobuf field: required double value = 2
     */
    value: number;
}
/**
 * Dogma effect definition
 *
 * @generated from protobuf message eve_multitools.data.TypeDogma.DogmaEffect
 */
export interface TypeDogma_DogmaEffect {
    /**
     * @generated from protobuf field: required int32 effect_id = 1
     */
    effectId: number;
    /**
     * @generated from protobuf field: required bool is_default = 2
     */
    isDefault: boolean;
}
/**
 * Type material definition
 * This mirrors the structure of typeMaterials.json in the FSD
 *
 * @generated from protobuf message eve_multitools.data.TypeMaterial
 */
export interface TypeMaterial {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeMaterial.Material materials = 1
     */
    materials: TypeMaterial_Material[];
}
/**
 * Material definition
 *
 * @generated from protobuf message eve_multitools.data.TypeMaterial.Material
 */
export interface TypeMaterial_Material {
    /**
     * @generated from protobuf field: required int32 material_type_id = 1
     */
    materialTypeId: number;
    /**
     * @generated from protobuf field: required int32 quantity = 2
     */
    quantity: number;
}
/**
 * Collection of all type IDs
 *
 * @generated from protobuf message eve_multitools.data.TypeCollection
 */
export interface TypeCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeCollection.TypeEntry types = 1
     */
    types: TypeCollection_TypeEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeCollection.TypeEntry
 */
export interface TypeCollection_TypeEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.TypeID type_data = 2
     */
    typeData?: TypeID;
}
/**
 * Collection of all type dogma data
 *
 * @generated from protobuf message eve_multitools.data.TypeDogmaCollection
 */
export interface TypeDogmaCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry type_dogmas = 1
     */
    typeDogmas: TypeDogmaCollection_TypeDogmaEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry
 */
export interface TypeDogmaCollection_TypeDogmaEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.TypeDogma type_dogma = 2
     */
    typeDogma?: TypeDogma;
}
/**
 * Collection of all type material data
 *
 * @generated from protobuf message eve_multitools.data.TypeMaterialCollection
 */
export interface TypeMaterialCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry type_materials = 1
     */
    typeMaterials: TypeMaterialCollection_TypeMaterialEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry
 */
export interface TypeMaterialCollection_TypeMaterialEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.TypeMaterial type_material = 2
     */
    typeMaterial?: TypeMaterial;
}
/**
 * Category definition
 *
 * @generated from protobuf message eve_multitools.data.Category
 */
export interface Category {
    /**
     * @generated from protobuf field: required int32 category_id = 1
     */
    categoryId: number;
    /**
     * @generated from protobuf field: required int32 category_name_id = 2
     */
    categoryNameId: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 3
     */
    iconId?: number;
    /**
     * @generated from protobuf field: required bool published = 4
     */
    published: boolean;
}
/**
 * Collection of all categories
 *
 * @generated from protobuf message eve_multitools.data.CategoryCollection
 */
export interface CategoryCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.CategoryCollection.CategoryEntry categories = 1
     */
    categories: CategoryCollection_CategoryEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.CategoryCollection.CategoryEntry
 */
export interface CategoryCollection_CategoryEntry {
    /**
     * @generated from protobuf field: required int32 category_id = 1
     */
    categoryId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.Category category_data = 2
     */
    categoryData?: Category;
}
/**
 * Group definition
 *
 * @generated from protobuf message eve_multitools.data.Group
 */
export interface Group {
    /**
     * @generated from protobuf field: required int32 group_id = 1
     */
    groupId: number;
    /**
     * @generated from protobuf field: required int32 group_name_id = 2
     */
    groupNameId: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 3
     */
    iconId?: number;
    /**
     * @generated from protobuf field: required int32 category_id = 4
     */
    categoryId: number;
    /**
     * @generated from protobuf field: required bool anchorable = 5
     */
    anchorable: boolean;
    /**
     * @generated from protobuf field: required bool fittable_non_singleton = 6
     */
    fittableNonSingleton: boolean;
    /**
     * @generated from protobuf field: required bool anchored = 7
     */
    anchored: boolean;
    /**
     * @generated from protobuf field: required bool published = 8
     */
    published: boolean;
    /**
     * @generated from protobuf field: required bool use_base_price = 9
     */
    useBasePrice: boolean;
}
/**
 * Collection of all groups
 *
 * @generated from protobuf message eve_multitools.data.GroupCollection
 */
export interface GroupCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.GroupCollection.GroupEntry groups = 1
     */
    groups: GroupCollection_GroupEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.GroupCollection.GroupEntry
 */
export interface GroupCollection_GroupEntry {
    /**
     * @generated from protobuf field: required int32 group_id = 1
     */
    groupId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.Group group_data = 2
     */
    groupData?: Group;
}
/**
 * MetaGroup definition
 *
 * @generated from protobuf message eve_multitools.data.MetaGroup
 */
export interface MetaGroup {
    /**
     * @generated from protobuf field: required int32 name_id = 1
     */
    nameId: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 2
     */
    iconId?: number;
}
/**
 * Collection of all meta groups
 *
 * @generated from protobuf message eve_multitools.data.MetaGroupCollection
 */
export interface MetaGroupCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.MetaGroupCollection.MetaGroupEntry meta_groups = 1
     */
    metaGroups: MetaGroupCollection_MetaGroupEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.MetaGroupCollection.MetaGroupEntry
 */
export interface MetaGroupCollection_MetaGroupEntry {
    /**
     * @generated from protobuf field: required int32 meta_group_id = 1
     */
    metaGroupId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.MetaGroup meta_group_data = 2
     */
    metaGroupData?: MetaGroup;
}
/**
 * Localization string definition
 *
 * @generated from protobuf message eve_multitools.data.LocalizationString
 */
export interface LocalizationString {
    /**
     * @generated from protobuf field: required string en = 1
     */
    en: string;
    /**
     * @generated from protobuf field: required string zh = 2
     */
    zh: string;
}
/**
 * Collection of all localization strings
 *
 * @generated from protobuf message eve_multitools.data.LocalizationCollection
 */
export interface LocalizationCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.LocalizationCollection.LocalizationEntry localizations = 1
     */
    localizations: LocalizationCollection_LocalizationEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.LocalizationCollection.LocalizationEntry
 */
export interface LocalizationCollection_LocalizationEntry {
    /**
     * @generated from protobuf field: required uint32 key = 1
     */
    key: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.LocalizationString localization_data = 2
     */
    localizationData?: LocalizationString;
}
/**
 * Type localization lookup data
 *
 * @generated from protobuf message eve_multitools.data.TypeLocalizationLookup
 */
export interface TypeLocalizationLookup {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.TypeLocalizationLookup.TypeLocEntry type_entries = 1
     */
    typeEntries: TypeLocalizationLookup_TypeLocEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.TypeLocalizationLookup.TypeLocEntry
 */
export interface TypeLocalizationLookup_TypeLocEntry {
    /**
     * @generated from protobuf field: required int32 type_id = 1
     */
    typeId: number;
    /**
     * @generated from protobuf field: required uint32 type_name_id = 2
     */
    typeNameId: number;
    /**
     * @generated from protobuf field: optional uint32 type_description_id = 3
     */
    typeDescriptionId?: number;
}
/**
 * @generated from protobuf message eve_multitools.data.RegionLocalizationLookup
 */
export interface RegionLocalizationLookup {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.RegionLocalizationLookup.RegionLocEntry region_entries = 1
     */
    regionEntries: RegionLocalizationLookup_RegionLocEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.RegionLocalizationLookup.RegionLocEntry
 */
export interface RegionLocalizationLookup_RegionLocEntry {
    /**
     * @generated from protobuf field: required int32 region_id = 1
     */
    regionId: number;
    /**
     * @generated from protobuf field: required uint32 name_id = 2
     */
    nameId: number;
    /**
     * @generated from protobuf field: optional uint32 description_id = 3
     */
    descriptionId?: number;
}
/**
 * @generated from protobuf message eve_multitools.data.ConstellationLocalizationLookup
 */
export interface ConstellationLocalizationLookup {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.ConstellationLocalizationLookup.ConstellationLocEntry constellation_entries = 1
     */
    constellationEntries: ConstellationLocalizationLookup_ConstellationLocEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.ConstellationLocalizationLookup.ConstellationLocEntry
 */
export interface ConstellationLocalizationLookup_ConstellationLocEntry {
    /**
     * @generated from protobuf field: required int32 constellation_id = 1
     */
    constellationId: number;
    /**
     * @generated from protobuf field: required uint32 name_id = 2
     */
    nameId: number;
}
/**
 * @generated from protobuf message eve_multitools.data.SystemLocalizationLookup
 */
export interface SystemLocalizationLookup {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.SystemLocalizationLookup.SystemLocEntry system_entries = 1
     */
    systemEntries: SystemLocalizationLookup_SystemLocEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.SystemLocalizationLookup.SystemLocEntry
 */
export interface SystemLocalizationLookup_SystemLocEntry {
    /**
     * @generated from protobuf field: required int32 system_id = 1
     */
    systemId: number;
    /**
     * @generated from protobuf field: required uint32 name_id = 2
     */
    nameId: number;
}
/**
 * Faction definition
 *
 * @generated from protobuf message eve_multitools.data.Faction
 */
export interface Faction {
    /**
     * @generated from protobuf field: required int32 name_id = 1
     */
    nameId: number;
    /**
     * @generated from protobuf field: required int32 description_id = 2
     */
    descriptionId: number;
    /**
     * @generated from protobuf field: optional int32 short_description_id = 3
     */
    shortDescriptionId?: number;
    /**
     * @generated from protobuf field: optional int32 corporation_id = 4
     */
    corporationId?: number;
    /**
     * @generated from protobuf field: required int32 icon_id = 5
     */
    iconId: number;
    /**
     * @generated from protobuf field: repeated int32 member_races = 6
     */
    memberRaces: number[];
    /**
     * @generated from protobuf field: required bool unique_name = 7
     */
    uniqueName: boolean;
    /**
     * @generated from protobuf field: optional string flat_logo = 8
     */
    flatLogo?: string;
    /**
     * @generated from protobuf field: optional string flat_logo_with_name = 9
     */
    flatLogoWithName?: string;
    /**
     * @generated from protobuf field: required int32 solar_system_id = 10
     */
    solarSystemId: number;
    /**
     * @generated from protobuf field: optional int32 militia_corporation_id = 11
     */
    militiaCorporationId?: number;
    /**
     * @generated from protobuf field: required double size_factor = 12
     */
    sizeFactor: number;
}
/**
 * Collection of all factions
 *
 * @generated from protobuf message eve_multitools.data.FactionCollection
 */
export interface FactionCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.FactionCollection.FactionEntry factions = 1
     */
    factions: FactionCollection_FactionEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.FactionCollection.FactionEntry
 */
export interface FactionCollection_FactionEntry {
    /**
     * @generated from protobuf field: required int32 faction_id = 1
     */
    factionId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.Faction faction_data = 2
     */
    factionData?: Faction;
}
/**
 * Market group definition
 *
 * @generated from protobuf message eve_multitools.data.MarketGroup
 */
export interface MarketGroup {
    /**
     * @generated from protobuf field: required int32 name_id = 1
     */
    nameId: number;
    /**
     * @generated from protobuf field: optional int32 description_id = 2
     */
    descriptionId?: number;
    /**
     * @generated from protobuf field: optional int32 icon_id = 3
     */
    iconId?: number;
    /**
     * @generated from protobuf field: optional int32 parent_group_id = 4
     */
    parentGroupId?: number;
    /**
     * @generated from protobuf field: repeated int32 groups = 5
     */
    groups: number[];
    /**
     * @generated from protobuf field: repeated int32 types = 6
     */
    types: number[];
}
/**
 * @generated from protobuf message eve_multitools.data.MarketGroupCollection
 */
export interface MarketGroupCollection {
    /**
     * @generated from protobuf field: repeated eve_multitools.data.MarketGroupCollection.MarketGroupEntry market_groups = 1
     */
    marketGroups: MarketGroupCollection_MarketGroupEntry[];
}
/**
 * @generated from protobuf message eve_multitools.data.MarketGroupCollection.MarketGroupEntry
 */
export interface MarketGroupCollection_MarketGroupEntry {
    /**
     * @generated from protobuf field: required int32 market_group_id = 1
     */
    marketGroupId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.MarketGroup market_group_data = 2
     */
    marketGroupData?: MarketGroup;
}
/**
 * @generated from protobuf message eve_multitools.data.UniversePoint
 */
export interface UniversePoint {
    /**
     * @generated from protobuf field: required double x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: required double y = 2
     */
    y: number;
    /**
     * @generated from protobuf field: required double z = 3
     */
    z: number;
}
/**
 * @generated from protobuf message eve_multitools.data.Rotation
 */
export interface Rotation {
    /**
     * @generated from protobuf field: required double yaw = 1
     */
    yaw: number;
    /**
     * @generated from protobuf field: required double pitch = 2
     */
    pitch: number;
    /**
     * @generated from protobuf field: required double roll = 3
     */
    roll: number;
}
/**
 * @generated from protobuf message eve_multitools.data.PointRotation
 */
export interface PointRotation {
    /**
     * @generated from protobuf field: required double x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: required double y = 2
     */
    y: number;
    /**
     * @generated from protobuf field: required double z = 3
     */
    z: number;
}
/**
 * @generated from protobuf message eve_multitools.data.Region
 */
export interface Region {
    /**
     * @generated from protobuf field: required int32 region_id = 1
     */
    regionId: number;
    /**
     * @generated from protobuf field: required int32 name_id = 2
     */
    nameId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint center = 3
     */
    center?: UniversePoint;
    /**
     * @generated from protobuf field: optional int32 description_id = 4
     */
    descriptionId?: number;
    /**
     * @generated from protobuf field: repeated int32 neighbours = 5
     */
    neighbours: number[];
    /**
     * @generated from protobuf field: repeated int32 constellation_ids = 6
     */
    constellationIds: number[];
    /**
     * @generated from protobuf field: repeated int32 solar_system_ids = 7
     */
    solarSystemIds: number[];
    /**
     * @generated from protobuf field: optional int32 faction_id = 8
     */
    factionId?: number;
    /**
     * @generated from protobuf field: optional eve_multitools.data.WormholeClassID wormhole_class_id = 9
     */
    wormholeClassId?: WormholeClassID;
    /**
     * @generated from protobuf field: optional eve_multitools.data.Region.RegionType region_type = 10
     */
    regionType?: Region_RegionType;
}
/**
 * @generated from protobuf enum eve_multitools.data.Region.RegionType
 */
export enum Region_RegionType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: HIGH_SEC = 1;
     */
    HIGH_SEC = 1,
    /**
     * @generated from protobuf enum value: LOW_SEC = 2;
     */
    LOW_SEC = 2,
    /**
     * @generated from protobuf enum value: NULL_SEC = 3;
     */
    NULL_SEC = 3,
    /**
     * @generated from protobuf enum value: WORMHOLE = 4;
     */
    WORMHOLE = 4,
    /**
     * @generated from protobuf enum value: VOID = 5;
     */
    VOID = 5,
    /**
     * @generated from protobuf enum value: ABYSSAL = 6;
     */
    ABYSSAL = 6,
    /**
     * @generated from protobuf enum value: POCHVEN = 7;
     */
    POCHVEN = 7,
}
/**
 * @generated from protobuf message eve_multitools.data.Constellation
 */
export interface Constellation {
    /**
     * @generated from protobuf field: required int32 constellation_id = 1
     */
    constellationId: number;
    /**
     * @generated from protobuf field: required int32 name_id = 2
     */
    nameId: number;
    /**
     * @generated from protobuf field: required int32 region_id = 3
     */
    regionId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint center = 4
     */
    center?: UniversePoint;
    /**
     * @generated from protobuf field: repeated int32 solar_system_ids = 5
     */
    solarSystemIds: number[];
    /**
     * @generated from protobuf field: optional int32 faction_id = 6
     */
    factionId?: number;
    /**
     * @generated from protobuf field: optional eve_multitools.data.WormholeClassID wormhole_class_id = 7
     */
    wormholeClassId?: WormholeClassID;
    /**
     * @generated from protobuf field: repeated int32 neighbours = 8
     */
    neighbours: number[];
}
/**
 * @generated from protobuf message eve_multitools.data.SolarSystem
 */
export interface SolarSystem {
    /**
     * @generated from protobuf field: required int32 solar_system_id = 1
     */
    solarSystemId: number;
    /**
     * @generated from protobuf field: required int32 solar_system_name_id = 2
     */
    solarSystemNameId: number;
    /**
     * @generated from protobuf field: required bool fringe = 3
     */
    fringe: boolean;
    /**
     * @generated from protobuf field: required bool hub = 4
     */
    hub: boolean;
    /**
     * @generated from protobuf field: required bool international = 5
     */
    international: boolean;
    /**
     * @generated from protobuf field: required bool regional = 6
     */
    regional: boolean;
    /**
     * @generated from protobuf field: required bool border = 7
     */
    border: boolean;
    /**
     * @generated from protobuf field: required bool corridor = 8
     */
    corridor: boolean;
    /**
     * @generated from protobuf field: required double luminosity = 9
     */
    luminosity: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint position = 10
     */
    position?: UniversePoint;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint max = 11
     */
    max?: UniversePoint;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint min = 12
     */
    min?: UniversePoint;
    /**
     * @generated from protobuf field: required double radius = 13
     */
    radius: number;
    /**
     * @generated from protobuf field: required double security = 14
     */
    security: number;
    /**
     * @generated from protobuf field: optional int32 description_id = 15
     */
    descriptionId?: number;
    /**
     * @generated from protobuf field: repeated int32 planets = 16
     */
    planets: number[];
    /**
     * @generated from protobuf field: optional eve_multitools.data.WormholeClassID wormhole_class_id = 17
     */
    wormholeClassId?: WormholeClassID;
    /**
     * @generated from protobuf field: optional int32 secondary_sun = 18
     */
    secondarySun?: number;
    /**
     * @generated from protobuf field: optional string security_class = 19
     */
    securityClass?: string;
    /**
     * @generated from protobuf field: optional int32 faction_id = 20
     */
    factionId?: number;
    /**
     * @generated from protobuf field: optional int32 sun_type_id = 21
     */
    sunTypeId?: number;
    /**
     * @generated from protobuf field: optional int32 sun_flare_graphic_id = 22
     */
    sunFlareGraphicId?: number;
    /**
     * @generated from protobuf field: optional int32 star = 23
     */
    star?: number;
    /**
     * @generated from protobuf field: repeated int32 stargates = 24
     */
    stargates: number[];
    /**
     * @generated from protobuf field: repeated int32 disrupted_stargates = 25
     */
    disruptedStargates: number[];
    /**
     * @generated from protobuf field: required int32 warp_tunnel_overwrite = 26
     */
    warpTunnelOverwrite: number;
    /**
     * @generated from protobuf field: required int32 system_wide_cloud = 27
     */
    systemWideCloud: number;
    /**
     * @generated from protobuf field: required string visual_effect = 28
     */
    visualEffect: string;
    /**
     * @generated from protobuf field: repeated int32 disallowed_anchor_groups = 29
     */
    disallowedAnchorGroups: number[];
    /**
     * @generated from protobuf field: repeated int32 disallowed_anchor_categories = 30
     */
    disallowedAnchorCategories: number[];
    /**
     * @generated from protobuf field: optional bool disallow_scanning = 31
     */
    disallowScanning?: boolean;
    /**
     * @generated from protobuf field: optional bool disallow_cyno = 32
     */
    disallowCyno?: boolean;
}
/**
 * @generated from protobuf message eve_multitools.data.CelestialAttributes
 */
export interface CelestialAttributes {
    /**
     * @generated from protobuf field: required int32 height_map1 = 1
     */
    heightMap1: number;
    /**
     * @generated from protobuf field: required int32 height_map2 = 2
     */
    heightMap2: number;
    /**
     * @generated from protobuf field: required bool population = 3
     */
    population: boolean;
    /**
     * @generated from protobuf field: required int32 shader_preset = 4
     */
    shaderPreset: number;
}
/**
 * @generated from protobuf message eve_multitools.data.CelestialStatistics
 */
export interface CelestialStatistics {
    /**
     * @generated from protobuf field: required double density = 1
     */
    density: number;
    /**
     * @generated from protobuf field: required double escape_velocity = 2
     */
    escapeVelocity: number;
    /**
     * @generated from protobuf field: required double eccentricity = 3
     */
    eccentricity: number;
    /**
     * @generated from protobuf field: required bool fragmented = 4
     */
    fragmented: boolean;
    /**
     * @generated from protobuf field: required double life = 5
     */
    life: number;
    /**
     * @generated from protobuf field: required bool locked = 6
     */
    locked: boolean;
    /**
     * @generated from protobuf field: required double mass_dust = 7
     */
    massDust: number;
    /**
     * @generated from protobuf field: required double mass_gas = 8
     */
    massGas: number;
    /**
     * @generated from protobuf field: required double orbit_period = 9
     */
    orbitPeriod: number;
    /**
     * @generated from protobuf field: required double orbit_radius = 10
     */
    orbitRadius: number;
    /**
     * @generated from protobuf field: required double pressure = 11
     */
    pressure: number;
    /**
     * @generated from protobuf field: required double radius = 12
     */
    radius: number;
    /**
     * @generated from protobuf field: required double rotation_rate = 13
     */
    rotationRate: number;
    /**
     * @generated from protobuf field: required double surface_gravity = 14
     */
    surfaceGravity: number;
    /**
     * @generated from protobuf field: required double temperature = 15
     */
    temperature: number;
    /**
     * @generated from protobuf field: required string spectral_class = 16
     */
    spectralClass: string;
}
/**
 * @generated from protobuf message eve_multitools.data.Planet
 */
export interface Planet {
    /**
     * @generated from protobuf field: required int32 planet_id = 1
     */
    planetId: number;
    /**
     * @generated from protobuf field: required int32 celestial_index = 2
     */
    celestialIndex: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.CelestialAttributes attributes = 3
     */
    attributes?: CelestialAttributes;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint position = 4
     */
    position?: UniversePoint;
    /**
     * @generated from protobuf field: required double radius = 5
     */
    radius: number;
    /**
     * @generated from protobuf field: required int32 type_id = 6
     */
    typeId: number;
    /**
     * @generated from protobuf field: required int32 solar_system_id = 7
     */
    solarSystemId: number;
    /**
     * @generated from protobuf field: optional int32 planet_name_id = 8
     */
    planetNameId?: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.CelestialStatistics statistics = 9
     */
    statistics?: CelestialStatistics;
    /**
     * @generated from protobuf field: repeated int32 moons = 10
     */
    moons: number[];
    /**
     * @generated from protobuf field: repeated int32 npc_stations = 11
     */
    npcStations: number[];
    /**
     * @generated from protobuf field: repeated int32 asteroid_belts = 12
     */
    asteroidBelts: number[];
}
/**
 * @generated from protobuf message eve_multitools.data.SecondarySun
 */
export interface SecondarySun {
    /**
     * @generated from protobuf field: required int32 sun_id = 1
     */
    sunId: number;
    /**
     * @generated from protobuf field: required int32 type_id = 2
     */
    typeId: number;
    /**
     * @generated from protobuf field: required int32 effect_beacon_type_id = 3
     */
    effectBeaconTypeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint position = 4
     */
    position?: UniversePoint;
    /**
     * @generated from protobuf field: required int32 system_id = 5
     */
    systemId: number;
}
/**
 * @generated from protobuf message eve_multitools.data.Star
 */
export interface Star {
    /**
     * @generated from protobuf field: required int32 star_id = 1
     */
    starId: number;
    /**
     * @generated from protobuf field: required double radius = 2
     */
    radius: number;
    /**
     * @generated from protobuf field: required int32 type_id = 3
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.Star.StarStatistics statistics = 4
     */
    statistics?: Star_StarStatistics;
    /**
     * @generated from protobuf field: repeated int32 npc_stations = 5
     */
    npcStations: number[];
    /**
     * @generated from protobuf field: required int32 system_id = 6
     */
    systemId: number;
}
/**
 * @generated from protobuf message eve_multitools.data.Star.StarStatistics
 */
export interface Star_StarStatistics {
    /**
     * @generated from protobuf field: required double age = 1
     */
    age: number;
    /**
     * @generated from protobuf field: required double life = 2
     */
    life: number;
    /**
     * @generated from protobuf field: required bool locked = 3
     */
    locked: boolean;
    /**
     * @generated from protobuf field: required double luminosity = 4
     */
    luminosity: number;
    /**
     * @generated from protobuf field: required double radius = 5
     */
    radius: number;
    /**
     * @generated from protobuf field: required double temperature = 6
     */
    temperature: number;
    /**
     * @generated from protobuf field: required string spectral_class = 7
     */
    spectralClass: string;
}
/**
 * @generated from protobuf message eve_multitools.data.Stargate
 */
export interface Stargate {
    /**
     * @generated from protobuf field: required int32 stargate_id = 1
     */
    stargateId: number;
    /**
     * @generated from protobuf field: required int32 destination = 2
     */
    destination: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint position = 3
     */
    position?: UniversePoint;
    /**
     * @generated from protobuf field: required int32 type_id = 4
     */
    typeId: number;
    /**
     * @generated from protobuf field: optional eve_multitools.data.Rotation rotation = 5
     */
    rotation?: Rotation;
    /**
     * @generated from protobuf field: optional bool ignored_by_corporation_defense_djinn = 6
     */
    ignoredByCorporationDefenseDjinn?: boolean;
    /**
     * @generated from protobuf field: optional int32 allowed_ships_type_list_id = 7
     */
    allowedShipsTypeListId?: number;
    /**
     * @generated from protobuf field: required int32 system_id = 8
     */
    systemId: number;
    /**
     * @generated from protobuf field: required int32 destination_system_id = 9
     */
    destinationSystemId: number;
}
/**
 * @generated from protobuf message eve_multitools.data.DisruptedStargate
 */
export interface DisruptedStargate {
    /**
     * @generated from protobuf field: required int32 stargate_id = 1
     */
    stargateId: number;
    /**
     * @generated from protobuf field: required int32 type_id = 2
     */
    typeId: number;
    /**
     * @generated from protobuf field: required int32 target_solar_system_id = 3
     */
    targetSolarSystemId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint position = 4
     */
    position?: UniversePoint;
    /**
     * @generated from protobuf field: required eve_multitools.data.PointRotation rotation = 5
     */
    rotation?: PointRotation;
    /**
     * @generated from protobuf field: required int32 system_id = 6
     */
    systemId: number;
}
/**
 * @generated from protobuf message eve_multitools.data.Moon
 */
export interface Moon {
    /**
     * @generated from protobuf field: required int32 moon_id = 1
     */
    moonId: number;
    /**
     * @generated from protobuf field: required int32 type_id = 2
     */
    typeId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.CelestialAttributes attributes = 3
     */
    attributes?: CelestialAttributes;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint position = 4
     */
    position?: UniversePoint;
    /**
     * @generated from protobuf field: required double radius = 5
     */
    radius: number;
    /**
     * @generated from protobuf field: required int32 orbit_id = 6
     */
    orbitId: number;
    /**
     * @generated from protobuf field: optional int32 moon_name_id = 7
     */
    moonNameId?: number;
    /**
     * @generated from protobuf field: repeated int32 npc_stations = 8
     */
    npcStations: number[];
    /**
     * @generated from protobuf field: optional eve_multitools.data.CelestialStatistics statistics = 9
     */
    statistics?: CelestialStatistics;
    /**
     * @generated from protobuf field: repeated int32 asteroid_belts = 10
     */
    asteroidBelts: number[];
    /**
     * @generated from protobuf field: optional eve_multitools.data.Moon.MiningBeacon mining_beacon = 11
     */
    miningBeacon?: Moon_MiningBeacon;
    /**
     * @generated from protobuf field: optional int32 environment_template_id = 12
     */
    environmentTemplateId?: number;
    /**
     * @generated from protobuf field: required int32 planet_id = 13
     */
    planetId: number;
    /**
     * @generated from protobuf field: required int32 celestial_index = 14
     */
    celestialIndex: number;
}
/**
 * @generated from protobuf message eve_multitools.data.Moon.MiningBeacon
 */
export interface Moon_MiningBeacon {
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint position = 1
     */
    position?: UniversePoint;
}
/**
 * @generated from protobuf message eve_multitools.data.NpcStation
 */
export interface NpcStation {
    /**
     * @generated from protobuf field: required int32 station_id = 1
     */
    stationId: number;
    /**
     * @generated from protobuf field: required bool is_conquerable = 2
     */
    isConquerable: boolean;
    /**
     * @generated from protobuf field: required int32 operation_id = 3
     */
    operationId: number;
    /**
     * @generated from protobuf field: required int32 owner_id = 4
     */
    ownerId: number;
    /**
     * @generated from protobuf field: required eve_multitools.data.UniversePoint position = 5
     */
    position?: UniversePoint;
    /**
     * @generated from protobuf field: required double reprocessing_efficiency = 6
     */
    reprocessingEfficiency: number;
    /**
     * @generated from protobuf field: required int32 reprocessing_hangar_flag = 7
     */
    reprocessingHangarFlag: number;
    /**
     * @generated from protobuf field: required double reprocessing_stations_take = 8
     */
    reprocessingStationsTake: number;
    /**
     * @generated from protobuf field: required int32 type_id = 9
     */
    typeId: number;
    /**
     * @generated from protobuf field: required bool use_operation_name = 10
     */
    useOperationName: boolean;
    /**
     * @generated from protobuf field: required int32 orbit_id = 11
     */
    orbitId: number;
    /**
     * @generated from protobuf field: required int32 graphic_id = 12
     */
    graphicId: number;
    /**
     * @generated from protobuf field: required int32 solar_system_id = 13
     */
    solarSystemId: number;
    /**
     * @generated from protobuf field: optional eve_multitools.data.Rotation rotation = 14
     */
    rotation?: Rotation;
    /**
     * @generated from protobuf field: required string station_name = 15
     */
    stationName: string;
    /**
     * @generated from protobuf field: optional bool ignored_by_corporation_defense_djinn = 16
     */
    ignoredByCorporationDefenseDjinn?: boolean;
    /**
     * @generated from protobuf field: optional int32 moon_id = 17
     */
    moonId?: number;
    /**
     * @generated from protobuf field: optional int32 planet_id = 18
     */
    planetId?: number;
    /**
     * @generated from protobuf field: optional int32 star_id = 19
     */
    starId?: number;
}
/**
 * @generated from protobuf message eve_multitools.data.AsteroidBelt
 */
export interface AsteroidBelt {
    /**
     * @generated from protobuf field: required int32 asteroid_belt_id = 1
     */
    asteroidBeltId: number;
    /**
     * @generated from protobuf field: required int32 type_id = 2
     */
    typeId: number;
    /**
     * @generated from protobuf field: optional int32 asteroid_belt_name_id = 3
     */
    asteroidBeltNameId?: number;
    /**
     * @generated from protobuf field: optional eve_multitools.data.CelestialStatistics statistics = 4
     */
    statistics?: CelestialStatistics;
    /**
     * @generated from protobuf field: optional int32 planet_id = 5
     */
    planetId?: number;
    /**
     * @generated from protobuf field: optional int32 moon_id = 6
     */
    moonId?: number;
}
/**
 * @generated from protobuf enum eve_multitools.data.WormholeClassID
 */
export enum WormholeClassID {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: C1 = 1;
     */
    C1 = 1,
    /**
     * @generated from protobuf enum value: C2 = 2;
     */
    C2 = 2,
    /**
     * @generated from protobuf enum value: C3 = 3;
     */
    C3 = 3,
    /**
     * @generated from protobuf enum value: C4 = 4;
     */
    C4 = 4,
    /**
     * @generated from protobuf enum value: C5 = 5;
     */
    C5 = 5,
    /**
     * @generated from protobuf enum value: C6 = 6;
     */
    C6 = 6,
    /**
     * @generated from protobuf enum value: HIGH_SEC_WM = 7;
     */
    HIGH_SEC_WM = 7,
    /**
     * @generated from protobuf enum value: LOW_SEC_WM = 8;
     */
    LOW_SEC_WM = 8,
    /**
     * @generated from protobuf enum value: NULL_SEC_WM = 9;
     */
    NULL_SEC_WM = 9,
    /**
     * @generated from protobuf enum value: GM1 = 10;
     */
    GM1 = 10,
    /**
     * @generated from protobuf enum value: GM2 = 11;
     */
    GM2 = 11,
    /**
     * @generated from protobuf enum value: THERA = 12;
     */
    THERA = 12,
    /**
     * @generated from protobuf enum value: SMALL_SHIP = 13;
     */
    SMALL_SHIP = 13,
    /**
     * @generated from protobuf enum value: SENTINEL = 14;
     */
    SENTINEL = 14,
    /**
     * @generated from protobuf enum value: BARBICAN = 15;
     */
    BARBICAN = 15,
    /**
     * @generated from protobuf enum value: VIDETTE = 16;
     */
    VIDETTE = 16,
    /**
     * @generated from protobuf enum value: CONFLUX = 17;
     */
    CONFLUX = 17,
    /**
     * @generated from protobuf enum value: REDOUBT = 18;
     */
    REDOUBT = 18,
    /**
     * @generated from protobuf enum value: VOID_OR_ABYSSAL1 = 19;
     */
    VOID_OR_ABYSSAL1 = 19,
    /**
     * @generated from protobuf enum value: ABYSSAL2 = 20;
     */
    ABYSSAL2 = 20,
    /**
     * @generated from protobuf enum value: ABYSSAL3 = 21;
     */
    ABYSSAL3 = 21,
    /**
     * @generated from protobuf enum value: ABYSSAL4 = 22;
     */
    ABYSSAL4 = 22,
    /**
     * @generated from protobuf enum value: ABYSSAL5 = 23;
     */
    ABYSSAL5 = 23,
    /**
     * @generated from protobuf enum value: POCHVEN_WM = 25;
     */
    POCHVEN_WM = 25,
}
// @generated message type with reflection information, may provide speed optimized methods
class TypeID$Type extends MessageType<TypeID> {
    constructor() {
        super("eve_multitools.data.TypeID", [
            { no: 1, name: "base_price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "capacity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            {
                no: 3,
                name: "certificate_template",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 4, name: "description_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 5,
                name: "designer_ids",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 6, name: "faction_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "graphic_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "is_dynamic_type", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "isis_group_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 12,
                name: "market_group_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 13, name: "meta_group_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "meta_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "portion_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "published", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            {
                no: 17,
                name: "quote_author_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 18, name: "quote_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "race_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 21, name: "sound_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "tech_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 24, name: "type_name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            {
                no: 25,
                name: "variation_parent_type_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 26, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 27, name: "wreck_type_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<TypeID>): TypeID {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.basePrice = 0;
        message.capacity = 0;
        message.designerIds = [];
        message.groupId = 0;
        message.isDynamicType = false;
        message.portionSize = 0;
        message.published = false;
        message.radius = 0;
        message.typeId = 0;
        message.typeNameId = 0;
        message.volume = 0;
        if (value !== undefined) reflectionMergePartial<TypeID>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeID
    ): TypeID {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required double base_price */ 1:
                    message.basePrice = reader.double();
                    break;
                case /* required double capacity */ 2:
                    message.capacity = reader.double();
                    break;
                case /* optional int32 certificate_template */ 3:
                    message.certificateTemplate = reader.int32();
                    break;
                case /* optional int32 description_id */ 4:
                    message.descriptionId = reader.int32();
                    break;
                case /* repeated int32 designer_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.designerIds.push(reader.int32());
                    else message.designerIds.push(reader.int32());
                    break;
                case /* optional int32 faction_id */ 6:
                    message.factionId = reader.int32();
                    break;
                case /* optional int32 graphic_id */ 7:
                    message.graphicId = reader.int32();
                    break;
                case /* required int32 group_id */ 8:
                    message.groupId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 9:
                    message.iconId = reader.int32();
                    break;
                case /* required bool is_dynamic_type */ 10:
                    message.isDynamicType = reader.bool();
                    break;
                case /* optional int32 isis_group_id */ 11:
                    message.isisGroupId = reader.int32();
                    break;
                case /* optional int32 market_group_id */ 12:
                    message.marketGroupId = reader.int32();
                    break;
                case /* optional int32 meta_group_id */ 13:
                    message.metaGroupId = reader.int32();
                    break;
                case /* optional int32 meta_level */ 14:
                    message.metaLevel = reader.int32();
                    break;
                case /* required int32 portion_size */ 15:
                    message.portionSize = reader.int32();
                    break;
                case /* required bool published */ 16:
                    message.published = reader.bool();
                    break;
                case /* optional int32 quote_author_id */ 17:
                    message.quoteAuthorId = reader.int32();
                    break;
                case /* optional int32 quote_id */ 18:
                    message.quoteId = reader.int32();
                    break;
                case /* optional int32 race_id */ 19:
                    message.raceId = reader.int32();
                    break;
                case /* required double radius */ 20:
                    message.radius = reader.double();
                    break;
                case /* optional int32 sound_id */ 21:
                    message.soundId = reader.int32();
                    break;
                case /* optional int32 tech_level */ 22:
                    message.techLevel = reader.int32();
                    break;
                case /* required int32 type_id */ 23:
                    message.typeId = reader.int32();
                    break;
                case /* required int32 type_name_id */ 24:
                    message.typeNameId = reader.int32();
                    break;
                case /* optional int32 variation_parent_type_id */ 25:
                    message.variationParentTypeId = reader.int32();
                    break;
                case /* required double volume */ 26:
                    message.volume = reader.double();
                    break;
                case /* optional int32 wreck_type_id */ 27:
                    message.wreckTypeId = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeID,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required double base_price = 1; */
        if (message.basePrice !== 0) writer.tag(1, WireType.Bit64).double(message.basePrice);
        /* required double capacity = 2; */
        if (message.capacity !== 0) writer.tag(2, WireType.Bit64).double(message.capacity);
        /* optional int32 certificate_template = 3; */
        if (message.certificateTemplate !== undefined)
            writer.tag(3, WireType.Varint).int32(message.certificateTemplate);
        /* optional int32 description_id = 4; */
        if (message.descriptionId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.descriptionId);
        /* repeated int32 designer_ids = 5; */
        for (let i = 0; i < message.designerIds.length; i++)
            writer.tag(5, WireType.Varint).int32(message.designerIds[i]);
        /* optional int32 faction_id = 6; */
        if (message.factionId !== undefined)
            writer.tag(6, WireType.Varint).int32(message.factionId);
        /* optional int32 graphic_id = 7; */
        if (message.graphicId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.graphicId);
        /* required int32 group_id = 8; */
        if (message.groupId !== 0) writer.tag(8, WireType.Varint).int32(message.groupId);
        /* optional int32 icon_id = 9; */
        if (message.iconId !== undefined) writer.tag(9, WireType.Varint).int32(message.iconId);
        /* required bool is_dynamic_type = 10; */
        if (message.isDynamicType !== false)
            writer.tag(10, WireType.Varint).bool(message.isDynamicType);
        /* optional int32 isis_group_id = 11; */
        if (message.isisGroupId !== undefined)
            writer.tag(11, WireType.Varint).int32(message.isisGroupId);
        /* optional int32 market_group_id = 12; */
        if (message.marketGroupId !== undefined)
            writer.tag(12, WireType.Varint).int32(message.marketGroupId);
        /* optional int32 meta_group_id = 13; */
        if (message.metaGroupId !== undefined)
            writer.tag(13, WireType.Varint).int32(message.metaGroupId);
        /* optional int32 meta_level = 14; */
        if (message.metaLevel !== undefined)
            writer.tag(14, WireType.Varint).int32(message.metaLevel);
        /* required int32 portion_size = 15; */
        if (message.portionSize !== 0) writer.tag(15, WireType.Varint).int32(message.portionSize);
        /* required bool published = 16; */
        if (message.published !== false) writer.tag(16, WireType.Varint).bool(message.published);
        /* optional int32 quote_author_id = 17; */
        if (message.quoteAuthorId !== undefined)
            writer.tag(17, WireType.Varint).int32(message.quoteAuthorId);
        /* optional int32 quote_id = 18; */
        if (message.quoteId !== undefined) writer.tag(18, WireType.Varint).int32(message.quoteId);
        /* optional int32 race_id = 19; */
        if (message.raceId !== undefined) writer.tag(19, WireType.Varint).int32(message.raceId);
        /* required double radius = 20; */
        if (message.radius !== 0) writer.tag(20, WireType.Bit64).double(message.radius);
        /* optional int32 sound_id = 21; */
        if (message.soundId !== undefined) writer.tag(21, WireType.Varint).int32(message.soundId);
        /* optional int32 tech_level = 22; */
        if (message.techLevel !== undefined)
            writer.tag(22, WireType.Varint).int32(message.techLevel);
        /* required int32 type_id = 23; */
        if (message.typeId !== 0) writer.tag(23, WireType.Varint).int32(message.typeId);
        /* required int32 type_name_id = 24; */
        if (message.typeNameId !== 0) writer.tag(24, WireType.Varint).int32(message.typeNameId);
        /* optional int32 variation_parent_type_id = 25; */
        if (message.variationParentTypeId !== undefined)
            writer.tag(25, WireType.Varint).int32(message.variationParentTypeId);
        /* required double volume = 26; */
        if (message.volume !== 0) writer.tag(26, WireType.Bit64).double(message.volume);
        /* optional int32 wreck_type_id = 27; */
        if (message.wreckTypeId !== undefined)
            writer.tag(27, WireType.Varint).int32(message.wreckTypeId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeID
 */
export const TypeID = new TypeID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogma$Type extends MessageType<TypeDogma> {
    constructor() {
        super("eve_multitools.data.TypeDogma", [
            {
                no: 1,
                name: "dogma_attributes",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeDogma_DogmaAttribute,
            },
            {
                no: 2,
                name: "dogma_effects",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeDogma_DogmaEffect,
            },
        ]);
    }
    create(value?: PartialMessage<TypeDogma>): TypeDogma {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.dogmaAttributes = [];
        message.dogmaEffects = [];
        if (value !== undefined) reflectionMergePartial<TypeDogma>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogma
    ): TypeDogma {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeDogma.DogmaAttribute dogma_attributes */ 1:
                    message.dogmaAttributes.push(
                        TypeDogma_DogmaAttribute.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                case /* repeated eve_multitools.data.TypeDogma.DogmaEffect dogma_effects */ 2:
                    message.dogmaEffects.push(
                        TypeDogma_DogmaEffect.internalBinaryRead(reader, reader.uint32(), options)
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogma,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeDogma.DogmaAttribute dogma_attributes = 1; */
        for (let i = 0; i < message.dogmaAttributes.length; i++)
            TypeDogma_DogmaAttribute.internalBinaryWrite(
                message.dogmaAttributes[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* repeated eve_multitools.data.TypeDogma.DogmaEffect dogma_effects = 2; */
        for (let i = 0; i < message.dogmaEffects.length; i++)
            TypeDogma_DogmaEffect.internalBinaryWrite(
                message.dogmaEffects[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogma
 */
export const TypeDogma = new TypeDogma$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogma_DogmaAttribute$Type extends MessageType<TypeDogma_DogmaAttribute> {
    constructor() {
        super("eve_multitools.data.TypeDogma.DogmaAttribute", [
            { no: 1, name: "attribute_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
        ]);
    }
    create(value?: PartialMessage<TypeDogma_DogmaAttribute>): TypeDogma_DogmaAttribute {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.attributeId = 0;
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeDogma_DogmaAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogma_DogmaAttribute
    ): TypeDogma_DogmaAttribute {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 attribute_id */ 1:
                    message.attributeId = reader.int32();
                    break;
                case /* required double value */ 2:
                    message.value = reader.double();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogma_DogmaAttribute,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 attribute_id = 1; */
        if (message.attributeId !== 0) writer.tag(1, WireType.Varint).int32(message.attributeId);
        /* required double value = 2; */
        if (message.value !== 0) writer.tag(2, WireType.Bit64).double(message.value);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogma.DogmaAttribute
 */
export const TypeDogma_DogmaAttribute = new TypeDogma_DogmaAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogma_DogmaEffect$Type extends MessageType<TypeDogma_DogmaEffect> {
    constructor() {
        super("eve_multitools.data.TypeDogma.DogmaEffect", [
            { no: 1, name: "effect_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "is_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
        ]);
    }
    create(value?: PartialMessage<TypeDogma_DogmaEffect>): TypeDogma_DogmaEffect {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.effectId = 0;
        message.isDefault = false;
        if (value !== undefined)
            reflectionMergePartial<TypeDogma_DogmaEffect>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogma_DogmaEffect
    ): TypeDogma_DogmaEffect {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 effect_id */ 1:
                    message.effectId = reader.int32();
                    break;
                case /* required bool is_default */ 2:
                    message.isDefault = reader.bool();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogma_DogmaEffect,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 effect_id = 1; */
        if (message.effectId !== 0) writer.tag(1, WireType.Varint).int32(message.effectId);
        /* required bool is_default = 2; */
        if (message.isDefault !== false) writer.tag(2, WireType.Varint).bool(message.isDefault);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogma.DogmaEffect
 */
export const TypeDogma_DogmaEffect = new TypeDogma_DogmaEffect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterial$Type extends MessageType<TypeMaterial> {
    constructor() {
        super("eve_multitools.data.TypeMaterial", [
            {
                no: 1,
                name: "materials",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeMaterial_Material,
            },
        ]);
    }
    create(value?: PartialMessage<TypeMaterial>): TypeMaterial {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.materials = [];
        if (value !== undefined) reflectionMergePartial<TypeMaterial>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeMaterial
    ): TypeMaterial {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeMaterial.Material materials */ 1:
                    message.materials.push(
                        TypeMaterial_Material.internalBinaryRead(reader, reader.uint32(), options)
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeMaterial,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeMaterial.Material materials = 1; */
        for (let i = 0; i < message.materials.length; i++)
            TypeMaterial_Material.internalBinaryWrite(
                message.materials[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterial
 */
export const TypeMaterial = new TypeMaterial$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterial_Material$Type extends MessageType<TypeMaterial_Material> {
    constructor() {
        super("eve_multitools.data.TypeMaterial.Material", [
            { no: 1, name: "material_type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<TypeMaterial_Material>): TypeMaterial_Material {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.materialTypeId = 0;
        message.quantity = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeMaterial_Material>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeMaterial_Material
    ): TypeMaterial_Material {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 material_type_id */ 1:
                    message.materialTypeId = reader.int32();
                    break;
                case /* required int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeMaterial_Material,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 material_type_id = 1; */
        if (message.materialTypeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.materialTypeId);
        /* required int32 quantity = 2; */
        if (message.quantity !== 0) writer.tag(2, WireType.Varint).int32(message.quantity);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterial.Material
 */
export const TypeMaterial_Material = new TypeMaterial_Material$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeCollection$Type extends MessageType<TypeCollection> {
    constructor() {
        super("eve_multitools.data.TypeCollection", [
            {
                no: 1,
                name: "types",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeCollection_TypeEntry,
            },
        ]);
    }
    create(value?: PartialMessage<TypeCollection>): TypeCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.types = [];
        if (value !== undefined) reflectionMergePartial<TypeCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeCollection
    ): TypeCollection {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeCollection.TypeEntry types */ 1:
                    message.types.push(
                        TypeCollection_TypeEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeCollection.TypeEntry types = 1; */
        for (let i = 0; i < message.types.length; i++)
            TypeCollection_TypeEntry.internalBinaryWrite(
                message.types[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeCollection
 */
export const TypeCollection = new TypeCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeCollection_TypeEntry$Type extends MessageType<TypeCollection_TypeEntry> {
    constructor() {
        super("eve_multitools.data.TypeCollection.TypeEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_data", kind: "message", T: () => TypeID },
        ]);
    }
    create(value?: PartialMessage<TypeCollection_TypeEntry>): TypeCollection_TypeEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeCollection_TypeEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeCollection_TypeEntry
    ): TypeCollection_TypeEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.TypeID type_data */ 2:
                    message.typeData = TypeID.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.typeData
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeCollection_TypeEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0) writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.TypeID type_data = 2; */
        if (message.typeData)
            TypeID.internalBinaryWrite(
                message.typeData,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeCollection.TypeEntry
 */
export const TypeCollection_TypeEntry = new TypeCollection_TypeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogmaCollection$Type extends MessageType<TypeDogmaCollection> {
    constructor() {
        super("eve_multitools.data.TypeDogmaCollection", [
            {
                no: 1,
                name: "type_dogmas",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeDogmaCollection_TypeDogmaEntry,
            },
        ]);
    }
    create(value?: PartialMessage<TypeDogmaCollection>): TypeDogmaCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeDogmas = [];
        if (value !== undefined) reflectionMergePartial<TypeDogmaCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogmaCollection
    ): TypeDogmaCollection {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry type_dogmas */ 1:
                    message.typeDogmas.push(
                        TypeDogmaCollection_TypeDogmaEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogmaCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry type_dogmas = 1; */
        for (let i = 0; i < message.typeDogmas.length; i++)
            TypeDogmaCollection_TypeDogmaEntry.internalBinaryWrite(
                message.typeDogmas[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogmaCollection
 */
export const TypeDogmaCollection = new TypeDogmaCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDogmaCollection_TypeDogmaEntry$Type extends MessageType<TypeDogmaCollection_TypeDogmaEntry> {
    constructor() {
        super("eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_dogma", kind: "message", T: () => TypeDogma },
        ]);
    }
    create(
        value?: PartialMessage<TypeDogmaCollection_TypeDogmaEntry>
    ): TypeDogmaCollection_TypeDogmaEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeDogmaCollection_TypeDogmaEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeDogmaCollection_TypeDogmaEntry
    ): TypeDogmaCollection_TypeDogmaEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.TypeDogma type_dogma */ 2:
                    message.typeDogma = TypeDogma.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.typeDogma
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeDogmaCollection_TypeDogmaEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0) writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.TypeDogma type_dogma = 2; */
        if (message.typeDogma)
            TypeDogma.internalBinaryWrite(
                message.typeDogma,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeDogmaCollection.TypeDogmaEntry
 */
export const TypeDogmaCollection_TypeDogmaEntry = new TypeDogmaCollection_TypeDogmaEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterialCollection$Type extends MessageType<TypeMaterialCollection> {
    constructor() {
        super("eve_multitools.data.TypeMaterialCollection", [
            {
                no: 1,
                name: "type_materials",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeMaterialCollection_TypeMaterialEntry,
            },
        ]);
    }
    create(value?: PartialMessage<TypeMaterialCollection>): TypeMaterialCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeMaterials = [];
        if (value !== undefined)
            reflectionMergePartial<TypeMaterialCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeMaterialCollection
    ): TypeMaterialCollection {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry type_materials */ 1:
                    message.typeMaterials.push(
                        TypeMaterialCollection_TypeMaterialEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeMaterialCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry type_materials = 1; */
        for (let i = 0; i < message.typeMaterials.length; i++)
            TypeMaterialCollection_TypeMaterialEntry.internalBinaryWrite(
                message.typeMaterials[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterialCollection
 */
export const TypeMaterialCollection = new TypeMaterialCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeMaterialCollection_TypeMaterialEntry$Type extends MessageType<TypeMaterialCollection_TypeMaterialEntry> {
    constructor() {
        super("eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_material", kind: "message", T: () => TypeMaterial },
        ]);
    }
    create(
        value?: PartialMessage<TypeMaterialCollection_TypeMaterialEntry>
    ): TypeMaterialCollection_TypeMaterialEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeMaterialCollection_TypeMaterialEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeMaterialCollection_TypeMaterialEntry
    ): TypeMaterialCollection_TypeMaterialEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.TypeMaterial type_material */ 2:
                    message.typeMaterial = TypeMaterial.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.typeMaterial
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeMaterialCollection_TypeMaterialEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0) writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.TypeMaterial type_material = 2; */
        if (message.typeMaterial)
            TypeMaterial.internalBinaryWrite(
                message.typeMaterial,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeMaterialCollection.TypeMaterialEntry
 */
export const TypeMaterialCollection_TypeMaterialEntry =
    new TypeMaterialCollection_TypeMaterialEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Category$Type extends MessageType<Category> {
    constructor() {
        super("eve_multitools.data.Category", [
            { no: 1, name: "category_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "category_name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "published", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
        ]);
    }
    create(value?: PartialMessage<Category>): Category {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.categoryId = 0;
        message.categoryNameId = 0;
        message.published = false;
        if (value !== undefined) reflectionMergePartial<Category>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Category
    ): Category {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 category_id */ 1:
                    message.categoryId = reader.int32();
                    break;
                case /* required int32 category_name_id */ 2:
                    message.categoryNameId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 3:
                    message.iconId = reader.int32();
                    break;
                case /* required bool published */ 4:
                    message.published = reader.bool();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Category,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 category_id = 1; */
        if (message.categoryId !== 0) writer.tag(1, WireType.Varint).int32(message.categoryId);
        /* required int32 category_name_id = 2; */
        if (message.categoryNameId !== 0)
            writer.tag(2, WireType.Varint).int32(message.categoryNameId);
        /* optional int32 icon_id = 3; */
        if (message.iconId !== undefined) writer.tag(3, WireType.Varint).int32(message.iconId);
        /* required bool published = 4; */
        if (message.published !== false) writer.tag(4, WireType.Varint).bool(message.published);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Category
 */
export const Category = new Category$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryCollection$Type extends MessageType<CategoryCollection> {
    constructor() {
        super("eve_multitools.data.CategoryCollection", [
            {
                no: 1,
                name: "categories",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => CategoryCollection_CategoryEntry,
            },
        ]);
    }
    create(value?: PartialMessage<CategoryCollection>): CategoryCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.categories = [];
        if (value !== undefined) reflectionMergePartial<CategoryCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CategoryCollection
    ): CategoryCollection {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.CategoryCollection.CategoryEntry categories */ 1:
                    message.categories.push(
                        CategoryCollection_CategoryEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: CategoryCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.CategoryCollection.CategoryEntry categories = 1; */
        for (let i = 0; i < message.categories.length; i++)
            CategoryCollection_CategoryEntry.internalBinaryWrite(
                message.categories[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.CategoryCollection
 */
export const CategoryCollection = new CategoryCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryCollection_CategoryEntry$Type extends MessageType<CategoryCollection_CategoryEntry> {
    constructor() {
        super("eve_multitools.data.CategoryCollection.CategoryEntry", [
            { no: 1, name: "category_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "category_data", kind: "message", T: () => Category },
        ]);
    }
    create(
        value?: PartialMessage<CategoryCollection_CategoryEntry>
    ): CategoryCollection_CategoryEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.categoryId = 0;
        if (value !== undefined)
            reflectionMergePartial<CategoryCollection_CategoryEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CategoryCollection_CategoryEntry
    ): CategoryCollection_CategoryEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 category_id */ 1:
                    message.categoryId = reader.int32();
                    break;
                case /* required eve_multitools.data.Category category_data */ 2:
                    message.categoryData = Category.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.categoryData
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: CategoryCollection_CategoryEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 category_id = 1; */
        if (message.categoryId !== 0) writer.tag(1, WireType.Varint).int32(message.categoryId);
        /* required eve_multitools.data.Category category_data = 2; */
        if (message.categoryData)
            Category.internalBinaryWrite(
                message.categoryData,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.CategoryCollection.CategoryEntry
 */
export const CategoryCollection_CategoryEntry = new CategoryCollection_CategoryEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Group$Type extends MessageType<Group> {
    constructor() {
        super("eve_multitools.data.Group", [
            { no: 1, name: "group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "group_name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "category_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "anchorable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "fittable_non_singleton", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "anchored", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "published", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "use_base_price", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
        ]);
    }
    create(value?: PartialMessage<Group>): Group {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.groupId = 0;
        message.groupNameId = 0;
        message.categoryId = 0;
        message.anchorable = false;
        message.fittableNonSingleton = false;
        message.anchored = false;
        message.published = false;
        message.useBasePrice = false;
        if (value !== undefined) reflectionMergePartial<Group>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Group
    ): Group {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 group_id */ 1:
                    message.groupId = reader.int32();
                    break;
                case /* required int32 group_name_id */ 2:
                    message.groupNameId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 3:
                    message.iconId = reader.int32();
                    break;
                case /* required int32 category_id */ 4:
                    message.categoryId = reader.int32();
                    break;
                case /* required bool anchorable */ 5:
                    message.anchorable = reader.bool();
                    break;
                case /* required bool fittable_non_singleton */ 6:
                    message.fittableNonSingleton = reader.bool();
                    break;
                case /* required bool anchored */ 7:
                    message.anchored = reader.bool();
                    break;
                case /* required bool published */ 8:
                    message.published = reader.bool();
                    break;
                case /* required bool use_base_price */ 9:
                    message.useBasePrice = reader.bool();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Group,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 group_id = 1; */
        if (message.groupId !== 0) writer.tag(1, WireType.Varint).int32(message.groupId);
        /* required int32 group_name_id = 2; */
        if (message.groupNameId !== 0) writer.tag(2, WireType.Varint).int32(message.groupNameId);
        /* optional int32 icon_id = 3; */
        if (message.iconId !== undefined) writer.tag(3, WireType.Varint).int32(message.iconId);
        /* required int32 category_id = 4; */
        if (message.categoryId !== 0) writer.tag(4, WireType.Varint).int32(message.categoryId);
        /* required bool anchorable = 5; */
        if (message.anchorable !== false) writer.tag(5, WireType.Varint).bool(message.anchorable);
        /* required bool fittable_non_singleton = 6; */
        if (message.fittableNonSingleton !== false)
            writer.tag(6, WireType.Varint).bool(message.fittableNonSingleton);
        /* required bool anchored = 7; */
        if (message.anchored !== false) writer.tag(7, WireType.Varint).bool(message.anchored);
        /* required bool published = 8; */
        if (message.published !== false) writer.tag(8, WireType.Varint).bool(message.published);
        /* required bool use_base_price = 9; */
        if (message.useBasePrice !== false)
            writer.tag(9, WireType.Varint).bool(message.useBasePrice);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Group
 */
export const Group = new Group$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupCollection$Type extends MessageType<GroupCollection> {
    constructor() {
        super("eve_multitools.data.GroupCollection", [
            {
                no: 1,
                name: "groups",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => GroupCollection_GroupEntry,
            },
        ]);
    }
    create(value?: PartialMessage<GroupCollection>): GroupCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.groups = [];
        if (value !== undefined) reflectionMergePartial<GroupCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GroupCollection
    ): GroupCollection {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.GroupCollection.GroupEntry groups */ 1:
                    message.groups.push(
                        GroupCollection_GroupEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GroupCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.GroupCollection.GroupEntry groups = 1; */
        for (let i = 0; i < message.groups.length; i++)
            GroupCollection_GroupEntry.internalBinaryWrite(
                message.groups[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.GroupCollection
 */
export const GroupCollection = new GroupCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupCollection_GroupEntry$Type extends MessageType<GroupCollection_GroupEntry> {
    constructor() {
        super("eve_multitools.data.GroupCollection.GroupEntry", [
            { no: 1, name: "group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "group_data", kind: "message", T: () => Group },
        ]);
    }
    create(value?: PartialMessage<GroupCollection_GroupEntry>): GroupCollection_GroupEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.groupId = 0;
        if (value !== undefined)
            reflectionMergePartial<GroupCollection_GroupEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GroupCollection_GroupEntry
    ): GroupCollection_GroupEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 group_id */ 1:
                    message.groupId = reader.int32();
                    break;
                case /* required eve_multitools.data.Group group_data */ 2:
                    message.groupData = Group.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.groupData
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GroupCollection_GroupEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 group_id = 1; */
        if (message.groupId !== 0) writer.tag(1, WireType.Varint).int32(message.groupId);
        /* required eve_multitools.data.Group group_data = 2; */
        if (message.groupData)
            Group.internalBinaryWrite(
                message.groupData,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.GroupCollection.GroupEntry
 */
export const GroupCollection_GroupEntry = new GroupCollection_GroupEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetaGroup$Type extends MessageType<MetaGroup> {
    constructor() {
        super("eve_multitools.data.MetaGroup", [
            { no: 1, name: "name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<MetaGroup>): MetaGroup {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.nameId = 0;
        if (value !== undefined) reflectionMergePartial<MetaGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: MetaGroup
    ): MetaGroup {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 name_id */ 1:
                    message.nameId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 2:
                    message.iconId = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: MetaGroup,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 name_id = 1; */
        if (message.nameId !== 0) writer.tag(1, WireType.Varint).int32(message.nameId);
        /* optional int32 icon_id = 2; */
        if (message.iconId !== undefined) writer.tag(2, WireType.Varint).int32(message.iconId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.MetaGroup
 */
export const MetaGroup = new MetaGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetaGroupCollection$Type extends MessageType<MetaGroupCollection> {
    constructor() {
        super("eve_multitools.data.MetaGroupCollection", [
            {
                no: 1,
                name: "meta_groups",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => MetaGroupCollection_MetaGroupEntry,
            },
        ]);
    }
    create(value?: PartialMessage<MetaGroupCollection>): MetaGroupCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.metaGroups = [];
        if (value !== undefined) reflectionMergePartial<MetaGroupCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: MetaGroupCollection
    ): MetaGroupCollection {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.MetaGroupCollection.MetaGroupEntry meta_groups */ 1:
                    message.metaGroups.push(
                        MetaGroupCollection_MetaGroupEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: MetaGroupCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.MetaGroupCollection.MetaGroupEntry meta_groups = 1; */
        for (let i = 0; i < message.metaGroups.length; i++)
            MetaGroupCollection_MetaGroupEntry.internalBinaryWrite(
                message.metaGroups[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.MetaGroupCollection
 */
export const MetaGroupCollection = new MetaGroupCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetaGroupCollection_MetaGroupEntry$Type extends MessageType<MetaGroupCollection_MetaGroupEntry> {
    constructor() {
        super("eve_multitools.data.MetaGroupCollection.MetaGroupEntry", [
            { no: 1, name: "meta_group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "meta_group_data", kind: "message", T: () => MetaGroup },
        ]);
    }
    create(
        value?: PartialMessage<MetaGroupCollection_MetaGroupEntry>
    ): MetaGroupCollection_MetaGroupEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.metaGroupId = 0;
        if (value !== undefined)
            reflectionMergePartial<MetaGroupCollection_MetaGroupEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: MetaGroupCollection_MetaGroupEntry
    ): MetaGroupCollection_MetaGroupEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 meta_group_id */ 1:
                    message.metaGroupId = reader.int32();
                    break;
                case /* required eve_multitools.data.MetaGroup meta_group_data */ 2:
                    message.metaGroupData = MetaGroup.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.metaGroupData
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: MetaGroupCollection_MetaGroupEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 meta_group_id = 1; */
        if (message.metaGroupId !== 0) writer.tag(1, WireType.Varint).int32(message.metaGroupId);
        /* required eve_multitools.data.MetaGroup meta_group_data = 2; */
        if (message.metaGroupData)
            MetaGroup.internalBinaryWrite(
                message.metaGroupData,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.MetaGroupCollection.MetaGroupEntry
 */
export const MetaGroupCollection_MetaGroupEntry = new MetaGroupCollection_MetaGroupEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalizationString$Type extends MessageType<LocalizationString> {
    constructor() {
        super("eve_multitools.data.LocalizationString", [
            { no: 1, name: "en", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "zh", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
        ]);
    }
    create(value?: PartialMessage<LocalizationString>): LocalizationString {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.en = "";
        message.zh = "";
        if (value !== undefined) reflectionMergePartial<LocalizationString>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: LocalizationString
    ): LocalizationString {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required string en */ 1:
                    message.en = reader.string();
                    break;
                case /* required string zh */ 2:
                    message.zh = reader.string();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: LocalizationString,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required string en = 1; */
        if (message.en !== "") writer.tag(1, WireType.LengthDelimited).string(message.en);
        /* required string zh = 2; */
        if (message.zh !== "") writer.tag(2, WireType.LengthDelimited).string(message.zh);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.LocalizationString
 */
export const LocalizationString = new LocalizationString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalizationCollection$Type extends MessageType<LocalizationCollection> {
    constructor() {
        super("eve_multitools.data.LocalizationCollection", [
            {
                no: 1,
                name: "localizations",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => LocalizationCollection_LocalizationEntry,
            },
        ]);
    }
    create(value?: PartialMessage<LocalizationCollection>): LocalizationCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.localizations = [];
        if (value !== undefined)
            reflectionMergePartial<LocalizationCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: LocalizationCollection
    ): LocalizationCollection {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.LocalizationCollection.LocalizationEntry localizations */ 1:
                    message.localizations.push(
                        LocalizationCollection_LocalizationEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: LocalizationCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.LocalizationCollection.LocalizationEntry localizations = 1; */
        for (let i = 0; i < message.localizations.length; i++)
            LocalizationCollection_LocalizationEntry.internalBinaryWrite(
                message.localizations[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.LocalizationCollection
 */
export const LocalizationCollection = new LocalizationCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalizationCollection_LocalizationEntry$Type extends MessageType<LocalizationCollection_LocalizationEntry> {
    constructor() {
        super("eve_multitools.data.LocalizationCollection.LocalizationEntry", [
            { no: 1, name: "key", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "localization_data", kind: "message", T: () => LocalizationString },
        ]);
    }
    create(
        value?: PartialMessage<LocalizationCollection_LocalizationEntry>
    ): LocalizationCollection_LocalizationEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.key = 0;
        if (value !== undefined)
            reflectionMergePartial<LocalizationCollection_LocalizationEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: LocalizationCollection_LocalizationEntry
    ): LocalizationCollection_LocalizationEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* required eve_multitools.data.LocalizationString localization_data */ 2:
                    message.localizationData = LocalizationString.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.localizationData
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: LocalizationCollection_LocalizationEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required uint32 key = 1; */
        if (message.key !== 0) writer.tag(1, WireType.Varint).uint32(message.key);
        /* required eve_multitools.data.LocalizationString localization_data = 2; */
        if (message.localizationData)
            LocalizationString.internalBinaryWrite(
                message.localizationData,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.LocalizationCollection.LocalizationEntry
 */
export const LocalizationCollection_LocalizationEntry =
    new LocalizationCollection_LocalizationEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeLocalizationLookup$Type extends MessageType<TypeLocalizationLookup> {
    constructor() {
        super("eve_multitools.data.TypeLocalizationLookup", [
            {
                no: 1,
                name: "type_entries",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TypeLocalizationLookup_TypeLocEntry,
            },
        ]);
    }
    create(value?: PartialMessage<TypeLocalizationLookup>): TypeLocalizationLookup {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeEntries = [];
        if (value !== undefined)
            reflectionMergePartial<TypeLocalizationLookup>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeLocalizationLookup
    ): TypeLocalizationLookup {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.TypeLocalizationLookup.TypeLocEntry type_entries */ 1:
                    message.typeEntries.push(
                        TypeLocalizationLookup_TypeLocEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeLocalizationLookup,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.TypeLocalizationLookup.TypeLocEntry type_entries = 1; */
        for (let i = 0; i < message.typeEntries.length; i++)
            TypeLocalizationLookup_TypeLocEntry.internalBinaryWrite(
                message.typeEntries[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeLocalizationLookup
 */
export const TypeLocalizationLookup = new TypeLocalizationLookup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeLocalizationLookup_TypeLocEntry$Type extends MessageType<TypeLocalizationLookup_TypeLocEntry> {
    constructor() {
        super("eve_multitools.data.TypeLocalizationLookup.TypeLocEntry", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_name_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            {
                no: 3,
                name: "type_description_id",
                kind: "scalar",
                opt: true,
                T: 13 /*ScalarType.UINT32*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<TypeLocalizationLookup_TypeLocEntry>
    ): TypeLocalizationLookup_TypeLocEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.typeId = 0;
        message.typeNameId = 0;
        if (value !== undefined)
            reflectionMergePartial<TypeLocalizationLookup_TypeLocEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TypeLocalizationLookup_TypeLocEntry
    ): TypeLocalizationLookup_TypeLocEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* required uint32 type_name_id */ 2:
                    message.typeNameId = reader.uint32();
                    break;
                case /* optional uint32 type_description_id */ 3:
                    message.typeDescriptionId = reader.uint32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TypeLocalizationLookup_TypeLocEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 type_id = 1; */
        if (message.typeId !== 0) writer.tag(1, WireType.Varint).int32(message.typeId);
        /* required uint32 type_name_id = 2; */
        if (message.typeNameId !== 0) writer.tag(2, WireType.Varint).uint32(message.typeNameId);
        /* optional uint32 type_description_id = 3; */
        if (message.typeDescriptionId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.typeDescriptionId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.TypeLocalizationLookup.TypeLocEntry
 */
export const TypeLocalizationLookup_TypeLocEntry = new TypeLocalizationLookup_TypeLocEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegionLocalizationLookup$Type extends MessageType<RegionLocalizationLookup> {
    constructor() {
        super("eve_multitools.data.RegionLocalizationLookup", [
            {
                no: 1,
                name: "region_entries",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => RegionLocalizationLookup_RegionLocEntry,
            },
        ]);
    }
    create(value?: PartialMessage<RegionLocalizationLookup>): RegionLocalizationLookup {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.regionEntries = [];
        if (value !== undefined)
            reflectionMergePartial<RegionLocalizationLookup>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RegionLocalizationLookup
    ): RegionLocalizationLookup {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.RegionLocalizationLookup.RegionLocEntry region_entries */ 1:
                    message.regionEntries.push(
                        RegionLocalizationLookup_RegionLocEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RegionLocalizationLookup,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.RegionLocalizationLookup.RegionLocEntry region_entries = 1; */
        for (let i = 0; i < message.regionEntries.length; i++)
            RegionLocalizationLookup_RegionLocEntry.internalBinaryWrite(
                message.regionEntries[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.RegionLocalizationLookup
 */
export const RegionLocalizationLookup = new RegionLocalizationLookup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegionLocalizationLookup_RegionLocEntry$Type extends MessageType<RegionLocalizationLookup_RegionLocEntry> {
    constructor() {
        super("eve_multitools.data.RegionLocalizationLookup.RegionLocEntry", [
            { no: 1, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            {
                no: 3,
                name: "description_id",
                kind: "scalar",
                opt: true,
                T: 13 /*ScalarType.UINT32*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<RegionLocalizationLookup_RegionLocEntry>
    ): RegionLocalizationLookup_RegionLocEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.regionId = 0;
        message.nameId = 0;
        if (value !== undefined)
            reflectionMergePartial<RegionLocalizationLookup_RegionLocEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RegionLocalizationLookup_RegionLocEntry
    ): RegionLocalizationLookup_RegionLocEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 region_id */ 1:
                    message.regionId = reader.int32();
                    break;
                case /* required uint32 name_id */ 2:
                    message.nameId = reader.uint32();
                    break;
                case /* optional uint32 description_id */ 3:
                    message.descriptionId = reader.uint32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RegionLocalizationLookup_RegionLocEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 region_id = 1; */
        if (message.regionId !== 0) writer.tag(1, WireType.Varint).int32(message.regionId);
        /* required uint32 name_id = 2; */
        if (message.nameId !== 0) writer.tag(2, WireType.Varint).uint32(message.nameId);
        /* optional uint32 description_id = 3; */
        if (message.descriptionId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.descriptionId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.RegionLocalizationLookup.RegionLocEntry
 */
export const RegionLocalizationLookup_RegionLocEntry =
    new RegionLocalizationLookup_RegionLocEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConstellationLocalizationLookup$Type extends MessageType<ConstellationLocalizationLookup> {
    constructor() {
        super("eve_multitools.data.ConstellationLocalizationLookup", [
            {
                no: 1,
                name: "constellation_entries",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => ConstellationLocalizationLookup_ConstellationLocEntry,
            },
        ]);
    }
    create(
        value?: PartialMessage<ConstellationLocalizationLookup>
    ): ConstellationLocalizationLookup {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.constellationEntries = [];
        if (value !== undefined)
            reflectionMergePartial<ConstellationLocalizationLookup>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ConstellationLocalizationLookup
    ): ConstellationLocalizationLookup {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.ConstellationLocalizationLookup.ConstellationLocEntry constellation_entries */ 1:
                    message.constellationEntries.push(
                        ConstellationLocalizationLookup_ConstellationLocEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ConstellationLocalizationLookup,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.ConstellationLocalizationLookup.ConstellationLocEntry constellation_entries = 1; */
        for (let i = 0; i < message.constellationEntries.length; i++)
            ConstellationLocalizationLookup_ConstellationLocEntry.internalBinaryWrite(
                message.constellationEntries[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.ConstellationLocalizationLookup
 */
export const ConstellationLocalizationLookup = new ConstellationLocalizationLookup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConstellationLocalizationLookup_ConstellationLocEntry$Type extends MessageType<ConstellationLocalizationLookup_ConstellationLocEntry> {
    constructor() {
        super("eve_multitools.data.ConstellationLocalizationLookup.ConstellationLocEntry", [
            { no: 1, name: "constellation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
        ]);
    }
    create(
        value?: PartialMessage<ConstellationLocalizationLookup_ConstellationLocEntry>
    ): ConstellationLocalizationLookup_ConstellationLocEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.constellationId = 0;
        message.nameId = 0;
        if (value !== undefined)
            reflectionMergePartial<ConstellationLocalizationLookup_ConstellationLocEntry>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ConstellationLocalizationLookup_ConstellationLocEntry
    ): ConstellationLocalizationLookup_ConstellationLocEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 constellation_id */ 1:
                    message.constellationId = reader.int32();
                    break;
                case /* required uint32 name_id */ 2:
                    message.nameId = reader.uint32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ConstellationLocalizationLookup_ConstellationLocEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 constellation_id = 1; */
        if (message.constellationId !== 0)
            writer.tag(1, WireType.Varint).int32(message.constellationId);
        /* required uint32 name_id = 2; */
        if (message.nameId !== 0) writer.tag(2, WireType.Varint).uint32(message.nameId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.ConstellationLocalizationLookup.ConstellationLocEntry
 */
export const ConstellationLocalizationLookup_ConstellationLocEntry =
    new ConstellationLocalizationLookup_ConstellationLocEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemLocalizationLookup$Type extends MessageType<SystemLocalizationLookup> {
    constructor() {
        super("eve_multitools.data.SystemLocalizationLookup", [
            {
                no: 1,
                name: "system_entries",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => SystemLocalizationLookup_SystemLocEntry,
            },
        ]);
    }
    create(value?: PartialMessage<SystemLocalizationLookup>): SystemLocalizationLookup {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.systemEntries = [];
        if (value !== undefined)
            reflectionMergePartial<SystemLocalizationLookup>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SystemLocalizationLookup
    ): SystemLocalizationLookup {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.SystemLocalizationLookup.SystemLocEntry system_entries */ 1:
                    message.systemEntries.push(
                        SystemLocalizationLookup_SystemLocEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SystemLocalizationLookup,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.SystemLocalizationLookup.SystemLocEntry system_entries = 1; */
        for (let i = 0; i < message.systemEntries.length; i++)
            SystemLocalizationLookup_SystemLocEntry.internalBinaryWrite(
                message.systemEntries[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.SystemLocalizationLookup
 */
export const SystemLocalizationLookup = new SystemLocalizationLookup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemLocalizationLookup_SystemLocEntry$Type extends MessageType<SystemLocalizationLookup_SystemLocEntry> {
    constructor() {
        super("eve_multitools.data.SystemLocalizationLookup.SystemLocEntry", [
            { no: 1, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
        ]);
    }
    create(
        value?: PartialMessage<SystemLocalizationLookup_SystemLocEntry>
    ): SystemLocalizationLookup_SystemLocEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.systemId = 0;
        message.nameId = 0;
        if (value !== undefined)
            reflectionMergePartial<SystemLocalizationLookup_SystemLocEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SystemLocalizationLookup_SystemLocEntry
    ): SystemLocalizationLookup_SystemLocEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 system_id */ 1:
                    message.systemId = reader.int32();
                    break;
                case /* required uint32 name_id */ 2:
                    message.nameId = reader.uint32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SystemLocalizationLookup_SystemLocEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 system_id = 1; */
        if (message.systemId !== 0) writer.tag(1, WireType.Varint).int32(message.systemId);
        /* required uint32 name_id = 2; */
        if (message.nameId !== 0) writer.tag(2, WireType.Varint).uint32(message.nameId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.SystemLocalizationLookup.SystemLocEntry
 */
export const SystemLocalizationLookup_SystemLocEntry =
    new SystemLocalizationLookup_SystemLocEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Faction$Type extends MessageType<Faction> {
    constructor() {
        super("eve_multitools.data.Faction", [
            { no: 1, name: "name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "description_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            {
                no: 3,
                name: "short_description_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 4, name: "corporation_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "icon_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            {
                no: 6,
                name: "member_races",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 7, name: "unique_name", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "flat_logo", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            {
                no: 9,
                name: "flat_logo_with_name",
                kind: "scalar",
                opt: true,
                T: 9 /*ScalarType.STRING*/,
            },
            { no: 10, name: "solar_system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            {
                no: 11,
                name: "militia_corporation_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 12, name: "size_factor", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
        ]);
    }
    create(value?: PartialMessage<Faction>): Faction {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.nameId = 0;
        message.descriptionId = 0;
        message.iconId = 0;
        message.memberRaces = [];
        message.uniqueName = false;
        message.solarSystemId = 0;
        message.sizeFactor = 0;
        if (value !== undefined) reflectionMergePartial<Faction>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Faction
    ): Faction {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 name_id */ 1:
                    message.nameId = reader.int32();
                    break;
                case /* required int32 description_id */ 2:
                    message.descriptionId = reader.int32();
                    break;
                case /* optional int32 short_description_id */ 3:
                    message.shortDescriptionId = reader.int32();
                    break;
                case /* optional int32 corporation_id */ 4:
                    message.corporationId = reader.int32();
                    break;
                case /* required int32 icon_id */ 5:
                    message.iconId = reader.int32();
                    break;
                case /* repeated int32 member_races */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.memberRaces.push(reader.int32());
                    else message.memberRaces.push(reader.int32());
                    break;
                case /* required bool unique_name */ 7:
                    message.uniqueName = reader.bool();
                    break;
                case /* optional string flat_logo */ 8:
                    message.flatLogo = reader.string();
                    break;
                case /* optional string flat_logo_with_name */ 9:
                    message.flatLogoWithName = reader.string();
                    break;
                case /* required int32 solar_system_id */ 10:
                    message.solarSystemId = reader.int32();
                    break;
                case /* optional int32 militia_corporation_id */ 11:
                    message.militiaCorporationId = reader.int32();
                    break;
                case /* required double size_factor */ 12:
                    message.sizeFactor = reader.double();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Faction,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 name_id = 1; */
        if (message.nameId !== 0) writer.tag(1, WireType.Varint).int32(message.nameId);
        /* required int32 description_id = 2; */
        if (message.descriptionId !== 0)
            writer.tag(2, WireType.Varint).int32(message.descriptionId);
        /* optional int32 short_description_id = 3; */
        if (message.shortDescriptionId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.shortDescriptionId);
        /* optional int32 corporation_id = 4; */
        if (message.corporationId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.corporationId);
        /* required int32 icon_id = 5; */
        if (message.iconId !== 0) writer.tag(5, WireType.Varint).int32(message.iconId);
        /* repeated int32 member_races = 6; */
        for (let i = 0; i < message.memberRaces.length; i++)
            writer.tag(6, WireType.Varint).int32(message.memberRaces[i]);
        /* required bool unique_name = 7; */
        if (message.uniqueName !== false) writer.tag(7, WireType.Varint).bool(message.uniqueName);
        /* optional string flat_logo = 8; */
        if (message.flatLogo !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.flatLogo);
        /* optional string flat_logo_with_name = 9; */
        if (message.flatLogoWithName !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.flatLogoWithName);
        /* required int32 solar_system_id = 10; */
        if (message.solarSystemId !== 0)
            writer.tag(10, WireType.Varint).int32(message.solarSystemId);
        /* optional int32 militia_corporation_id = 11; */
        if (message.militiaCorporationId !== undefined)
            writer.tag(11, WireType.Varint).int32(message.militiaCorporationId);
        /* required double size_factor = 12; */
        if (message.sizeFactor !== 0) writer.tag(12, WireType.Bit64).double(message.sizeFactor);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Faction
 */
export const Faction = new Faction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FactionCollection$Type extends MessageType<FactionCollection> {
    constructor() {
        super("eve_multitools.data.FactionCollection", [
            {
                no: 1,
                name: "factions",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => FactionCollection_FactionEntry,
            },
        ]);
    }
    create(value?: PartialMessage<FactionCollection>): FactionCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.factions = [];
        if (value !== undefined) reflectionMergePartial<FactionCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: FactionCollection
    ): FactionCollection {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.FactionCollection.FactionEntry factions */ 1:
                    message.factions.push(
                        FactionCollection_FactionEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: FactionCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.FactionCollection.FactionEntry factions = 1; */
        for (let i = 0; i < message.factions.length; i++)
            FactionCollection_FactionEntry.internalBinaryWrite(
                message.factions[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.FactionCollection
 */
export const FactionCollection = new FactionCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FactionCollection_FactionEntry$Type extends MessageType<FactionCollection_FactionEntry> {
    constructor() {
        super("eve_multitools.data.FactionCollection.FactionEntry", [
            { no: 1, name: "faction_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "faction_data", kind: "message", T: () => Faction },
        ]);
    }
    create(value?: PartialMessage<FactionCollection_FactionEntry>): FactionCollection_FactionEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.factionId = 0;
        if (value !== undefined)
            reflectionMergePartial<FactionCollection_FactionEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: FactionCollection_FactionEntry
    ): FactionCollection_FactionEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 faction_id */ 1:
                    message.factionId = reader.int32();
                    break;
                case /* required eve_multitools.data.Faction faction_data */ 2:
                    message.factionData = Faction.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.factionData
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: FactionCollection_FactionEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 faction_id = 1; */
        if (message.factionId !== 0) writer.tag(1, WireType.Varint).int32(message.factionId);
        /* required eve_multitools.data.Faction faction_data = 2; */
        if (message.factionData)
            Faction.internalBinaryWrite(
                message.factionData,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.FactionCollection.FactionEntry
 */
export const FactionCollection_FactionEntry = new FactionCollection_FactionEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketGroup$Type extends MessageType<MarketGroup> {
    constructor() {
        super("eve_multitools.data.MarketGroup", [
            { no: 1, name: "name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "description_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "icon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 4,
                name: "parent_group_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 5,
                name: "groups",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 6,
                name: "types",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
        ]);
    }
    create(value?: PartialMessage<MarketGroup>): MarketGroup {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.nameId = 0;
        message.groups = [];
        message.types = [];
        if (value !== undefined) reflectionMergePartial<MarketGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: MarketGroup
    ): MarketGroup {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 name_id */ 1:
                    message.nameId = reader.int32();
                    break;
                case /* optional int32 description_id */ 2:
                    message.descriptionId = reader.int32();
                    break;
                case /* optional int32 icon_id */ 3:
                    message.iconId = reader.int32();
                    break;
                case /* optional int32 parent_group_id */ 4:
                    message.parentGroupId = reader.int32();
                    break;
                case /* repeated int32 groups */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.groups.push(reader.int32());
                    else message.groups.push(reader.int32());
                    break;
                case /* repeated int32 types */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.types.push(reader.int32());
                    else message.types.push(reader.int32());
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: MarketGroup,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 name_id = 1; */
        if (message.nameId !== 0) writer.tag(1, WireType.Varint).int32(message.nameId);
        /* optional int32 description_id = 2; */
        if (message.descriptionId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.descriptionId);
        /* optional int32 icon_id = 3; */
        if (message.iconId !== undefined) writer.tag(3, WireType.Varint).int32(message.iconId);
        /* optional int32 parent_group_id = 4; */
        if (message.parentGroupId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.parentGroupId);
        /* repeated int32 groups = 5; */
        for (let i = 0; i < message.groups.length; i++)
            writer.tag(5, WireType.Varint).int32(message.groups[i]);
        /* repeated int32 types = 6; */
        for (let i = 0; i < message.types.length; i++)
            writer.tag(6, WireType.Varint).int32(message.types[i]);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.MarketGroup
 */
export const MarketGroup = new MarketGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketGroupCollection$Type extends MessageType<MarketGroupCollection> {
    constructor() {
        super("eve_multitools.data.MarketGroupCollection", [
            {
                no: 1,
                name: "market_groups",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => MarketGroupCollection_MarketGroupEntry,
            },
        ]);
    }
    create(value?: PartialMessage<MarketGroupCollection>): MarketGroupCollection {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.marketGroups = [];
        if (value !== undefined)
            reflectionMergePartial<MarketGroupCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: MarketGroupCollection
    ): MarketGroupCollection {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_multitools.data.MarketGroupCollection.MarketGroupEntry market_groups */ 1:
                    message.marketGroups.push(
                        MarketGroupCollection_MarketGroupEntry.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: MarketGroupCollection,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated eve_multitools.data.MarketGroupCollection.MarketGroupEntry market_groups = 1; */
        for (let i = 0; i < message.marketGroups.length; i++)
            MarketGroupCollection_MarketGroupEntry.internalBinaryWrite(
                message.marketGroups[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.MarketGroupCollection
 */
export const MarketGroupCollection = new MarketGroupCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketGroupCollection_MarketGroupEntry$Type extends MessageType<MarketGroupCollection_MarketGroupEntry> {
    constructor() {
        super("eve_multitools.data.MarketGroupCollection.MarketGroupEntry", [
            { no: 1, name: "market_group_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "market_group_data", kind: "message", T: () => MarketGroup },
        ]);
    }
    create(
        value?: PartialMessage<MarketGroupCollection_MarketGroupEntry>
    ): MarketGroupCollection_MarketGroupEntry {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.marketGroupId = 0;
        if (value !== undefined)
            reflectionMergePartial<MarketGroupCollection_MarketGroupEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: MarketGroupCollection_MarketGroupEntry
    ): MarketGroupCollection_MarketGroupEntry {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 market_group_id */ 1:
                    message.marketGroupId = reader.int32();
                    break;
                case /* required eve_multitools.data.MarketGroup market_group_data */ 2:
                    message.marketGroupData = MarketGroup.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.marketGroupData
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: MarketGroupCollection_MarketGroupEntry,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 market_group_id = 1; */
        if (message.marketGroupId !== 0)
            writer.tag(1, WireType.Varint).int32(message.marketGroupId);
        /* required eve_multitools.data.MarketGroup market_group_data = 2; */
        if (message.marketGroupData)
            MarketGroup.internalBinaryWrite(
                message.marketGroupData,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.MarketGroupCollection.MarketGroupEntry
 */
export const MarketGroupCollection_MarketGroupEntry =
    new MarketGroupCollection_MarketGroupEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniversePoint$Type extends MessageType<UniversePoint> {
    constructor() {
        super("eve_multitools.data.UniversePoint", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "z", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
        ]);
    }
    create(value?: PartialMessage<UniversePoint>): UniversePoint {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.x = 0;
        message.y = 0;
        message.z = 0;
        if (value !== undefined) reflectionMergePartial<UniversePoint>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UniversePoint
    ): UniversePoint {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required double x */ 1:
                    message.x = reader.double();
                    break;
                case /* required double y */ 2:
                    message.y = reader.double();
                    break;
                case /* required double z */ 3:
                    message.z = reader.double();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: UniversePoint,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required double x = 1; */
        if (message.x !== 0) writer.tag(1, WireType.Bit64).double(message.x);
        /* required double y = 2; */
        if (message.y !== 0) writer.tag(2, WireType.Bit64).double(message.y);
        /* required double z = 3; */
        if (message.z !== 0) writer.tag(3, WireType.Bit64).double(message.z);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.UniversePoint
 */
export const UniversePoint = new UniversePoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rotation$Type extends MessageType<Rotation> {
    constructor() {
        super("eve_multitools.data.Rotation", [
            { no: 1, name: "yaw", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "pitch", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "roll", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
        ]);
    }
    create(value?: PartialMessage<Rotation>): Rotation {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.yaw = 0;
        message.pitch = 0;
        message.roll = 0;
        if (value !== undefined) reflectionMergePartial<Rotation>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Rotation
    ): Rotation {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required double yaw */ 1:
                    message.yaw = reader.double();
                    break;
                case /* required double pitch */ 2:
                    message.pitch = reader.double();
                    break;
                case /* required double roll */ 3:
                    message.roll = reader.double();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Rotation,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required double yaw = 1; */
        if (message.yaw !== 0) writer.tag(1, WireType.Bit64).double(message.yaw);
        /* required double pitch = 2; */
        if (message.pitch !== 0) writer.tag(2, WireType.Bit64).double(message.pitch);
        /* required double roll = 3; */
        if (message.roll !== 0) writer.tag(3, WireType.Bit64).double(message.roll);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Rotation
 */
export const Rotation = new Rotation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointRotation$Type extends MessageType<PointRotation> {
    constructor() {
        super("eve_multitools.data.PointRotation", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "z", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
        ]);
    }
    create(value?: PartialMessage<PointRotation>): PointRotation {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.x = 0;
        message.y = 0;
        message.z = 0;
        if (value !== undefined) reflectionMergePartial<PointRotation>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PointRotation
    ): PointRotation {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required double x */ 1:
                    message.x = reader.double();
                    break;
                case /* required double y */ 2:
                    message.y = reader.double();
                    break;
                case /* required double z */ 3:
                    message.z = reader.double();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: PointRotation,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required double x = 1; */
        if (message.x !== 0) writer.tag(1, WireType.Bit64).double(message.x);
        /* required double y = 2; */
        if (message.y !== 0) writer.tag(2, WireType.Bit64).double(message.y);
        /* required double z = 3; */
        if (message.z !== 0) writer.tag(3, WireType.Bit64).double(message.z);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.PointRotation
 */
export const PointRotation = new PointRotation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Region$Type extends MessageType<Region> {
    constructor() {
        super("eve_multitools.data.Region", [
            { no: 1, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "center", kind: "message", T: () => UniversePoint },
            { no: 4, name: "description_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 5,
                name: "neighbours",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 6,
                name: "constellation_ids",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 7,
                name: "solar_system_ids",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 8, name: "faction_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 9,
                name: "wormhole_class_id",
                kind: "enum",
                opt: true,
                T: () => ["eve_multitools.data.WormholeClassID", WormholeClassID],
            },
            {
                no: 10,
                name: "region_type",
                kind: "enum",
                opt: true,
                T: () => ["eve_multitools.data.Region.RegionType", Region_RegionType],
            },
        ]);
    }
    create(value?: PartialMessage<Region>): Region {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.regionId = 0;
        message.nameId = 0;
        message.neighbours = [];
        message.constellationIds = [];
        message.solarSystemIds = [];
        if (value !== undefined) reflectionMergePartial<Region>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Region
    ): Region {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 region_id */ 1:
                    message.regionId = reader.int32();
                    break;
                case /* required int32 name_id */ 2:
                    message.nameId = reader.int32();
                    break;
                case /* required eve_multitools.data.UniversePoint center */ 3:
                    message.center = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.center
                    );
                    break;
                case /* optional int32 description_id */ 4:
                    message.descriptionId = reader.int32();
                    break;
                case /* repeated int32 neighbours */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.neighbours.push(reader.int32());
                    else message.neighbours.push(reader.int32());
                    break;
                case /* repeated int32 constellation_ids */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.constellationIds.push(reader.int32());
                    else message.constellationIds.push(reader.int32());
                    break;
                case /* repeated int32 solar_system_ids */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.solarSystemIds.push(reader.int32());
                    else message.solarSystemIds.push(reader.int32());
                    break;
                case /* optional int32 faction_id */ 8:
                    message.factionId = reader.int32();
                    break;
                case /* optional eve_multitools.data.WormholeClassID wormhole_class_id */ 9:
                    message.wormholeClassId = reader.int32();
                    break;
                case /* optional eve_multitools.data.Region.RegionType region_type */ 10:
                    message.regionType = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Region,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 region_id = 1; */
        if (message.regionId !== 0) writer.tag(1, WireType.Varint).int32(message.regionId);
        /* required int32 name_id = 2; */
        if (message.nameId !== 0) writer.tag(2, WireType.Varint).int32(message.nameId);
        /* required eve_multitools.data.UniversePoint center = 3; */
        if (message.center)
            UniversePoint.internalBinaryWrite(
                message.center,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* optional int32 description_id = 4; */
        if (message.descriptionId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.descriptionId);
        /* repeated int32 neighbours = 5; */
        for (let i = 0; i < message.neighbours.length; i++)
            writer.tag(5, WireType.Varint).int32(message.neighbours[i]);
        /* repeated int32 constellation_ids = 6; */
        for (let i = 0; i < message.constellationIds.length; i++)
            writer.tag(6, WireType.Varint).int32(message.constellationIds[i]);
        /* repeated int32 solar_system_ids = 7; */
        for (let i = 0; i < message.solarSystemIds.length; i++)
            writer.tag(7, WireType.Varint).int32(message.solarSystemIds[i]);
        /* optional int32 faction_id = 8; */
        if (message.factionId !== undefined)
            writer.tag(8, WireType.Varint).int32(message.factionId);
        /* optional eve_multitools.data.WormholeClassID wormhole_class_id = 9; */
        if (message.wormholeClassId !== undefined)
            writer.tag(9, WireType.Varint).int32(message.wormholeClassId);
        /* optional eve_multitools.data.Region.RegionType region_type = 10; */
        if (message.regionType !== undefined)
            writer.tag(10, WireType.Varint).int32(message.regionType);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Region
 */
export const Region = new Region$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Constellation$Type extends MessageType<Constellation> {
    constructor() {
        super("eve_multitools.data.Constellation", [
            { no: 1, name: "constellation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "center", kind: "message", T: () => UniversePoint },
            {
                no: 5,
                name: "solar_system_ids",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 6, name: "faction_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 7,
                name: "wormhole_class_id",
                kind: "enum",
                opt: true,
                T: () => ["eve_multitools.data.WormholeClassID", WormholeClassID],
            },
            {
                no: 8,
                name: "neighbours",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
        ]);
    }
    create(value?: PartialMessage<Constellation>): Constellation {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.constellationId = 0;
        message.nameId = 0;
        message.regionId = 0;
        message.solarSystemIds = [];
        message.neighbours = [];
        if (value !== undefined) reflectionMergePartial<Constellation>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Constellation
    ): Constellation {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 constellation_id */ 1:
                    message.constellationId = reader.int32();
                    break;
                case /* required int32 name_id */ 2:
                    message.nameId = reader.int32();
                    break;
                case /* required int32 region_id */ 3:
                    message.regionId = reader.int32();
                    break;
                case /* required eve_multitools.data.UniversePoint center */ 4:
                    message.center = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.center
                    );
                    break;
                case /* repeated int32 solar_system_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.solarSystemIds.push(reader.int32());
                    else message.solarSystemIds.push(reader.int32());
                    break;
                case /* optional int32 faction_id */ 6:
                    message.factionId = reader.int32();
                    break;
                case /* optional eve_multitools.data.WormholeClassID wormhole_class_id */ 7:
                    message.wormholeClassId = reader.int32();
                    break;
                case /* repeated int32 neighbours */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.neighbours.push(reader.int32());
                    else message.neighbours.push(reader.int32());
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Constellation,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 constellation_id = 1; */
        if (message.constellationId !== 0)
            writer.tag(1, WireType.Varint).int32(message.constellationId);
        /* required int32 name_id = 2; */
        if (message.nameId !== 0) writer.tag(2, WireType.Varint).int32(message.nameId);
        /* required int32 region_id = 3; */
        if (message.regionId !== 0) writer.tag(3, WireType.Varint).int32(message.regionId);
        /* required eve_multitools.data.UniversePoint center = 4; */
        if (message.center)
            UniversePoint.internalBinaryWrite(
                message.center,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* repeated int32 solar_system_ids = 5; */
        for (let i = 0; i < message.solarSystemIds.length; i++)
            writer.tag(5, WireType.Varint).int32(message.solarSystemIds[i]);
        /* optional int32 faction_id = 6; */
        if (message.factionId !== undefined)
            writer.tag(6, WireType.Varint).int32(message.factionId);
        /* optional eve_multitools.data.WormholeClassID wormhole_class_id = 7; */
        if (message.wormholeClassId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.wormholeClassId);
        /* repeated int32 neighbours = 8; */
        for (let i = 0; i < message.neighbours.length; i++)
            writer.tag(8, WireType.Varint).int32(message.neighbours[i]);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Constellation
 */
export const Constellation = new Constellation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SolarSystem$Type extends MessageType<SolarSystem> {
    constructor() {
        super("eve_multitools.data.SolarSystem", [
            { no: 1, name: "solar_system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "solar_system_name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "fringe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "hub", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "international", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "regional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "border", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "corridor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "luminosity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "position", kind: "message", T: () => UniversePoint },
            { no: 11, name: "max", kind: "message", T: () => UniversePoint },
            { no: 12, name: "min", kind: "message", T: () => UniversePoint },
            { no: 13, name: "radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "security", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            {
                no: 15,
                name: "description_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 16,
                name: "planets",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 17,
                name: "wormhole_class_id",
                kind: "enum",
                opt: true,
                T: () => ["eve_multitools.data.WormholeClassID", WormholeClassID],
            },
            { no: 18, name: "secondary_sun", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 19,
                name: "security_class",
                kind: "scalar",
                opt: true,
                T: 9 /*ScalarType.STRING*/,
            },
            { no: 20, name: "faction_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "sun_type_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 22,
                name: "sun_flare_graphic_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 23, name: "star", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 24,
                name: "stargates",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 25,
                name: "disrupted_stargates",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 26, name: "warp_tunnel_overwrite", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "system_wide_cloud", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 28, name: "visual_effect", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            {
                no: 29,
                name: "disallowed_anchor_groups",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 30,
                name: "disallowed_anchor_categories",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 31,
                name: "disallow_scanning",
                kind: "scalar",
                opt: true,
                T: 8 /*ScalarType.BOOL*/,
            },
            { no: 32, name: "disallow_cyno", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
        ]);
    }
    create(value?: PartialMessage<SolarSystem>): SolarSystem {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.solarSystemId = 0;
        message.solarSystemNameId = 0;
        message.fringe = false;
        message.hub = false;
        message.international = false;
        message.regional = false;
        message.border = false;
        message.corridor = false;
        message.luminosity = 0;
        message.radius = 0;
        message.security = 0;
        message.planets = [];
        message.stargates = [];
        message.disruptedStargates = [];
        message.warpTunnelOverwrite = 0;
        message.systemWideCloud = 0;
        message.visualEffect = "";
        message.disallowedAnchorGroups = [];
        message.disallowedAnchorCategories = [];
        if (value !== undefined) reflectionMergePartial<SolarSystem>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SolarSystem
    ): SolarSystem {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 solar_system_id */ 1:
                    message.solarSystemId = reader.int32();
                    break;
                case /* required int32 solar_system_name_id */ 2:
                    message.solarSystemNameId = reader.int32();
                    break;
                case /* required bool fringe */ 3:
                    message.fringe = reader.bool();
                    break;
                case /* required bool hub */ 4:
                    message.hub = reader.bool();
                    break;
                case /* required bool international */ 5:
                    message.international = reader.bool();
                    break;
                case /* required bool regional */ 6:
                    message.regional = reader.bool();
                    break;
                case /* required bool border */ 7:
                    message.border = reader.bool();
                    break;
                case /* required bool corridor */ 8:
                    message.corridor = reader.bool();
                    break;
                case /* required double luminosity */ 9:
                    message.luminosity = reader.double();
                    break;
                case /* required eve_multitools.data.UniversePoint position */ 10:
                    message.position = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.position
                    );
                    break;
                case /* required eve_multitools.data.UniversePoint max */ 11:
                    message.max = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.max
                    );
                    break;
                case /* required eve_multitools.data.UniversePoint min */ 12:
                    message.min = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.min
                    );
                    break;
                case /* required double radius */ 13:
                    message.radius = reader.double();
                    break;
                case /* required double security */ 14:
                    message.security = reader.double();
                    break;
                case /* optional int32 description_id */ 15:
                    message.descriptionId = reader.int32();
                    break;
                case /* repeated int32 planets */ 16:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.planets.push(reader.int32());
                    else message.planets.push(reader.int32());
                    break;
                case /* optional eve_multitools.data.WormholeClassID wormhole_class_id */ 17:
                    message.wormholeClassId = reader.int32();
                    break;
                case /* optional int32 secondary_sun */ 18:
                    message.secondarySun = reader.int32();
                    break;
                case /* optional string security_class */ 19:
                    message.securityClass = reader.string();
                    break;
                case /* optional int32 faction_id */ 20:
                    message.factionId = reader.int32();
                    break;
                case /* optional int32 sun_type_id */ 21:
                    message.sunTypeId = reader.int32();
                    break;
                case /* optional int32 sun_flare_graphic_id */ 22:
                    message.sunFlareGraphicId = reader.int32();
                    break;
                case /* optional int32 star */ 23:
                    message.star = reader.int32();
                    break;
                case /* repeated int32 stargates */ 24:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.stargates.push(reader.int32());
                    else message.stargates.push(reader.int32());
                    break;
                case /* repeated int32 disrupted_stargates */ 25:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.disruptedStargates.push(reader.int32());
                    else message.disruptedStargates.push(reader.int32());
                    break;
                case /* required int32 warp_tunnel_overwrite */ 26:
                    message.warpTunnelOverwrite = reader.int32();
                    break;
                case /* required int32 system_wide_cloud */ 27:
                    message.systemWideCloud = reader.int32();
                    break;
                case /* required string visual_effect */ 28:
                    message.visualEffect = reader.string();
                    break;
                case /* repeated int32 disallowed_anchor_groups */ 29:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.disallowedAnchorGroups.push(reader.int32());
                    else message.disallowedAnchorGroups.push(reader.int32());
                    break;
                case /* repeated int32 disallowed_anchor_categories */ 30:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.disallowedAnchorCategories.push(reader.int32());
                    else message.disallowedAnchorCategories.push(reader.int32());
                    break;
                case /* optional bool disallow_scanning */ 31:
                    message.disallowScanning = reader.bool();
                    break;
                case /* optional bool disallow_cyno */ 32:
                    message.disallowCyno = reader.bool();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SolarSystem,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 solar_system_id = 1; */
        if (message.solarSystemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.solarSystemId);
        /* required int32 solar_system_name_id = 2; */
        if (message.solarSystemNameId !== 0)
            writer.tag(2, WireType.Varint).int32(message.solarSystemNameId);
        /* required bool fringe = 3; */
        if (message.fringe !== false) writer.tag(3, WireType.Varint).bool(message.fringe);
        /* required bool hub = 4; */
        if (message.hub !== false) writer.tag(4, WireType.Varint).bool(message.hub);
        /* required bool international = 5; */
        if (message.international !== false)
            writer.tag(5, WireType.Varint).bool(message.international);
        /* required bool regional = 6; */
        if (message.regional !== false) writer.tag(6, WireType.Varint).bool(message.regional);
        /* required bool border = 7; */
        if (message.border !== false) writer.tag(7, WireType.Varint).bool(message.border);
        /* required bool corridor = 8; */
        if (message.corridor !== false) writer.tag(8, WireType.Varint).bool(message.corridor);
        /* required double luminosity = 9; */
        if (message.luminosity !== 0) writer.tag(9, WireType.Bit64).double(message.luminosity);
        /* required eve_multitools.data.UniversePoint position = 10; */
        if (message.position)
            UniversePoint.internalBinaryWrite(
                message.position,
                writer.tag(10, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required eve_multitools.data.UniversePoint max = 11; */
        if (message.max)
            UniversePoint.internalBinaryWrite(
                message.max,
                writer.tag(11, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required eve_multitools.data.UniversePoint min = 12; */
        if (message.min)
            UniversePoint.internalBinaryWrite(
                message.min,
                writer.tag(12, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required double radius = 13; */
        if (message.radius !== 0) writer.tag(13, WireType.Bit64).double(message.radius);
        /* required double security = 14; */
        if (message.security !== 0) writer.tag(14, WireType.Bit64).double(message.security);
        /* optional int32 description_id = 15; */
        if (message.descriptionId !== undefined)
            writer.tag(15, WireType.Varint).int32(message.descriptionId);
        /* repeated int32 planets = 16; */
        for (let i = 0; i < message.planets.length; i++)
            writer.tag(16, WireType.Varint).int32(message.planets[i]);
        /* optional eve_multitools.data.WormholeClassID wormhole_class_id = 17; */
        if (message.wormholeClassId !== undefined)
            writer.tag(17, WireType.Varint).int32(message.wormholeClassId);
        /* optional int32 secondary_sun = 18; */
        if (message.secondarySun !== undefined)
            writer.tag(18, WireType.Varint).int32(message.secondarySun);
        /* optional string security_class = 19; */
        if (message.securityClass !== undefined)
            writer.tag(19, WireType.LengthDelimited).string(message.securityClass);
        /* optional int32 faction_id = 20; */
        if (message.factionId !== undefined)
            writer.tag(20, WireType.Varint).int32(message.factionId);
        /* optional int32 sun_type_id = 21; */
        if (message.sunTypeId !== undefined)
            writer.tag(21, WireType.Varint).int32(message.sunTypeId);
        /* optional int32 sun_flare_graphic_id = 22; */
        if (message.sunFlareGraphicId !== undefined)
            writer.tag(22, WireType.Varint).int32(message.sunFlareGraphicId);
        /* optional int32 star = 23; */
        if (message.star !== undefined) writer.tag(23, WireType.Varint).int32(message.star);
        /* repeated int32 stargates = 24; */
        for (let i = 0; i < message.stargates.length; i++)
            writer.tag(24, WireType.Varint).int32(message.stargates[i]);
        /* repeated int32 disrupted_stargates = 25; */
        for (let i = 0; i < message.disruptedStargates.length; i++)
            writer.tag(25, WireType.Varint).int32(message.disruptedStargates[i]);
        /* required int32 warp_tunnel_overwrite = 26; */
        if (message.warpTunnelOverwrite !== 0)
            writer.tag(26, WireType.Varint).int32(message.warpTunnelOverwrite);
        /* required int32 system_wide_cloud = 27; */
        if (message.systemWideCloud !== 0)
            writer.tag(27, WireType.Varint).int32(message.systemWideCloud);
        /* required string visual_effect = 28; */
        if (message.visualEffect !== "")
            writer.tag(28, WireType.LengthDelimited).string(message.visualEffect);
        /* repeated int32 disallowed_anchor_groups = 29; */
        for (let i = 0; i < message.disallowedAnchorGroups.length; i++)
            writer.tag(29, WireType.Varint).int32(message.disallowedAnchorGroups[i]);
        /* repeated int32 disallowed_anchor_categories = 30; */
        for (let i = 0; i < message.disallowedAnchorCategories.length; i++)
            writer.tag(30, WireType.Varint).int32(message.disallowedAnchorCategories[i]);
        /* optional bool disallow_scanning = 31; */
        if (message.disallowScanning !== undefined)
            writer.tag(31, WireType.Varint).bool(message.disallowScanning);
        /* optional bool disallow_cyno = 32; */
        if (message.disallowCyno !== undefined)
            writer.tag(32, WireType.Varint).bool(message.disallowCyno);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.SolarSystem
 */
export const SolarSystem = new SolarSystem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CelestialAttributes$Type extends MessageType<CelestialAttributes> {
    constructor() {
        super("eve_multitools.data.CelestialAttributes", [
            { no: 1, name: "height_map1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "height_map2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "population", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "shader_preset", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<CelestialAttributes>): CelestialAttributes {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.heightMap1 = 0;
        message.heightMap2 = 0;
        message.population = false;
        message.shaderPreset = 0;
        if (value !== undefined) reflectionMergePartial<CelestialAttributes>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CelestialAttributes
    ): CelestialAttributes {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 height_map1 */ 1:
                    message.heightMap1 = reader.int32();
                    break;
                case /* required int32 height_map2 */ 2:
                    message.heightMap2 = reader.int32();
                    break;
                case /* required bool population */ 3:
                    message.population = reader.bool();
                    break;
                case /* required int32 shader_preset */ 4:
                    message.shaderPreset = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: CelestialAttributes,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 height_map1 = 1; */
        if (message.heightMap1 !== 0) writer.tag(1, WireType.Varint).int32(message.heightMap1);
        /* required int32 height_map2 = 2; */
        if (message.heightMap2 !== 0) writer.tag(2, WireType.Varint).int32(message.heightMap2);
        /* required bool population = 3; */
        if (message.population !== false) writer.tag(3, WireType.Varint).bool(message.population);
        /* required int32 shader_preset = 4; */
        if (message.shaderPreset !== 0) writer.tag(4, WireType.Varint).int32(message.shaderPreset);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.CelestialAttributes
 */
export const CelestialAttributes = new CelestialAttributes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CelestialStatistics$Type extends MessageType<CelestialStatistics> {
    constructor() {
        super("eve_multitools.data.CelestialStatistics", [
            { no: 1, name: "density", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "escape_velocity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "eccentricity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "fragmented", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "life", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "mass_dust", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "mass_gas", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "orbit_period", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "orbit_radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "pressure", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "rotation_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "surface_gravity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 15, name: "temperature", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "spectral_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
        ]);
    }
    create(value?: PartialMessage<CelestialStatistics>): CelestialStatistics {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.density = 0;
        message.escapeVelocity = 0;
        message.eccentricity = 0;
        message.fragmented = false;
        message.life = 0;
        message.locked = false;
        message.massDust = 0;
        message.massGas = 0;
        message.orbitPeriod = 0;
        message.orbitRadius = 0;
        message.pressure = 0;
        message.radius = 0;
        message.rotationRate = 0;
        message.surfaceGravity = 0;
        message.temperature = 0;
        message.spectralClass = "";
        if (value !== undefined) reflectionMergePartial<CelestialStatistics>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CelestialStatistics
    ): CelestialStatistics {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required double density */ 1:
                    message.density = reader.double();
                    break;
                case /* required double escape_velocity */ 2:
                    message.escapeVelocity = reader.double();
                    break;
                case /* required double eccentricity */ 3:
                    message.eccentricity = reader.double();
                    break;
                case /* required bool fragmented */ 4:
                    message.fragmented = reader.bool();
                    break;
                case /* required double life */ 5:
                    message.life = reader.double();
                    break;
                case /* required bool locked */ 6:
                    message.locked = reader.bool();
                    break;
                case /* required double mass_dust */ 7:
                    message.massDust = reader.double();
                    break;
                case /* required double mass_gas */ 8:
                    message.massGas = reader.double();
                    break;
                case /* required double orbit_period */ 9:
                    message.orbitPeriod = reader.double();
                    break;
                case /* required double orbit_radius */ 10:
                    message.orbitRadius = reader.double();
                    break;
                case /* required double pressure */ 11:
                    message.pressure = reader.double();
                    break;
                case /* required double radius */ 12:
                    message.radius = reader.double();
                    break;
                case /* required double rotation_rate */ 13:
                    message.rotationRate = reader.double();
                    break;
                case /* required double surface_gravity */ 14:
                    message.surfaceGravity = reader.double();
                    break;
                case /* required double temperature */ 15:
                    message.temperature = reader.double();
                    break;
                case /* required string spectral_class */ 16:
                    message.spectralClass = reader.string();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: CelestialStatistics,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required double density = 1; */
        if (message.density !== 0) writer.tag(1, WireType.Bit64).double(message.density);
        /* required double escape_velocity = 2; */
        if (message.escapeVelocity !== 0)
            writer.tag(2, WireType.Bit64).double(message.escapeVelocity);
        /* required double eccentricity = 3; */
        if (message.eccentricity !== 0) writer.tag(3, WireType.Bit64).double(message.eccentricity);
        /* required bool fragmented = 4; */
        if (message.fragmented !== false) writer.tag(4, WireType.Varint).bool(message.fragmented);
        /* required double life = 5; */
        if (message.life !== 0) writer.tag(5, WireType.Bit64).double(message.life);
        /* required bool locked = 6; */
        if (message.locked !== false) writer.tag(6, WireType.Varint).bool(message.locked);
        /* required double mass_dust = 7; */
        if (message.massDust !== 0) writer.tag(7, WireType.Bit64).double(message.massDust);
        /* required double mass_gas = 8; */
        if (message.massGas !== 0) writer.tag(8, WireType.Bit64).double(message.massGas);
        /* required double orbit_period = 9; */
        if (message.orbitPeriod !== 0) writer.tag(9, WireType.Bit64).double(message.orbitPeriod);
        /* required double orbit_radius = 10; */
        if (message.orbitRadius !== 0) writer.tag(10, WireType.Bit64).double(message.orbitRadius);
        /* required double pressure = 11; */
        if (message.pressure !== 0) writer.tag(11, WireType.Bit64).double(message.pressure);
        /* required double radius = 12; */
        if (message.radius !== 0) writer.tag(12, WireType.Bit64).double(message.radius);
        /* required double rotation_rate = 13; */
        if (message.rotationRate !== 0) writer.tag(13, WireType.Bit64).double(message.rotationRate);
        /* required double surface_gravity = 14; */
        if (message.surfaceGravity !== 0)
            writer.tag(14, WireType.Bit64).double(message.surfaceGravity);
        /* required double temperature = 15; */
        if (message.temperature !== 0) writer.tag(15, WireType.Bit64).double(message.temperature);
        /* required string spectral_class = 16; */
        if (message.spectralClass !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.spectralClass);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.CelestialStatistics
 */
export const CelestialStatistics = new CelestialStatistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Planet$Type extends MessageType<Planet> {
    constructor() {
        super("eve_multitools.data.Planet", [
            { no: 1, name: "planet_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "celestial_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "attributes", kind: "message", T: () => CelestialAttributes },
            { no: 4, name: "position", kind: "message", T: () => UniversePoint },
            { no: 5, name: "radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "solar_system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "planet_name_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "statistics", kind: "message", T: () => CelestialStatistics },
            {
                no: 10,
                name: "moons",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 11,
                name: "npc_stations",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 12,
                name: "asteroid_belts",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
        ]);
    }
    create(value?: PartialMessage<Planet>): Planet {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.planetId = 0;
        message.celestialIndex = 0;
        message.radius = 0;
        message.typeId = 0;
        message.solarSystemId = 0;
        message.moons = [];
        message.npcStations = [];
        message.asteroidBelts = [];
        if (value !== undefined) reflectionMergePartial<Planet>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Planet
    ): Planet {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 planet_id */ 1:
                    message.planetId = reader.int32();
                    break;
                case /* required int32 celestial_index */ 2:
                    message.celestialIndex = reader.int32();
                    break;
                case /* required eve_multitools.data.CelestialAttributes attributes */ 3:
                    message.attributes = CelestialAttributes.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.attributes
                    );
                    break;
                case /* required eve_multitools.data.UniversePoint position */ 4:
                    message.position = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.position
                    );
                    break;
                case /* required double radius */ 5:
                    message.radius = reader.double();
                    break;
                case /* required int32 type_id */ 6:
                    message.typeId = reader.int32();
                    break;
                case /* required int32 solar_system_id */ 7:
                    message.solarSystemId = reader.int32();
                    break;
                case /* optional int32 planet_name_id */ 8:
                    message.planetNameId = reader.int32();
                    break;
                case /* required eve_multitools.data.CelestialStatistics statistics */ 9:
                    message.statistics = CelestialStatistics.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.statistics
                    );
                    break;
                case /* repeated int32 moons */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.moons.push(reader.int32());
                    else message.moons.push(reader.int32());
                    break;
                case /* repeated int32 npc_stations */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.npcStations.push(reader.int32());
                    else message.npcStations.push(reader.int32());
                    break;
                case /* repeated int32 asteroid_belts */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.asteroidBelts.push(reader.int32());
                    else message.asteroidBelts.push(reader.int32());
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Planet,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 planet_id = 1; */
        if (message.planetId !== 0) writer.tag(1, WireType.Varint).int32(message.planetId);
        /* required int32 celestial_index = 2; */
        if (message.celestialIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.celestialIndex);
        /* required eve_multitools.data.CelestialAttributes attributes = 3; */
        if (message.attributes)
            CelestialAttributes.internalBinaryWrite(
                message.attributes,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required eve_multitools.data.UniversePoint position = 4; */
        if (message.position)
            UniversePoint.internalBinaryWrite(
                message.position,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required double radius = 5; */
        if (message.radius !== 0) writer.tag(5, WireType.Bit64).double(message.radius);
        /* required int32 type_id = 6; */
        if (message.typeId !== 0) writer.tag(6, WireType.Varint).int32(message.typeId);
        /* required int32 solar_system_id = 7; */
        if (message.solarSystemId !== 0)
            writer.tag(7, WireType.Varint).int32(message.solarSystemId);
        /* optional int32 planet_name_id = 8; */
        if (message.planetNameId !== undefined)
            writer.tag(8, WireType.Varint).int32(message.planetNameId);
        /* required eve_multitools.data.CelestialStatistics statistics = 9; */
        if (message.statistics)
            CelestialStatistics.internalBinaryWrite(
                message.statistics,
                writer.tag(9, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* repeated int32 moons = 10; */
        for (let i = 0; i < message.moons.length; i++)
            writer.tag(10, WireType.Varint).int32(message.moons[i]);
        /* repeated int32 npc_stations = 11; */
        for (let i = 0; i < message.npcStations.length; i++)
            writer.tag(11, WireType.Varint).int32(message.npcStations[i]);
        /* repeated int32 asteroid_belts = 12; */
        for (let i = 0; i < message.asteroidBelts.length; i++)
            writer.tag(12, WireType.Varint).int32(message.asteroidBelts[i]);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Planet
 */
export const Planet = new Planet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecondarySun$Type extends MessageType<SecondarySun> {
    constructor() {
        super("eve_multitools.data.SecondarySun", [
            { no: 1, name: "sun_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "effect_beacon_type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "position", kind: "message", T: () => UniversePoint },
            { no: 5, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<SecondarySun>): SecondarySun {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.sunId = 0;
        message.typeId = 0;
        message.effectBeaconTypeId = 0;
        message.systemId = 0;
        if (value !== undefined) reflectionMergePartial<SecondarySun>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SecondarySun
    ): SecondarySun {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 sun_id */ 1:
                    message.sunId = reader.int32();
                    break;
                case /* required int32 type_id */ 2:
                    message.typeId = reader.int32();
                    break;
                case /* required int32 effect_beacon_type_id */ 3:
                    message.effectBeaconTypeId = reader.int32();
                    break;
                case /* required eve_multitools.data.UniversePoint position */ 4:
                    message.position = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.position
                    );
                    break;
                case /* required int32 system_id */ 5:
                    message.systemId = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SecondarySun,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 sun_id = 1; */
        if (message.sunId !== 0) writer.tag(1, WireType.Varint).int32(message.sunId);
        /* required int32 type_id = 2; */
        if (message.typeId !== 0) writer.tag(2, WireType.Varint).int32(message.typeId);
        /* required int32 effect_beacon_type_id = 3; */
        if (message.effectBeaconTypeId !== 0)
            writer.tag(3, WireType.Varint).int32(message.effectBeaconTypeId);
        /* required eve_multitools.data.UniversePoint position = 4; */
        if (message.position)
            UniversePoint.internalBinaryWrite(
                message.position,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required int32 system_id = 5; */
        if (message.systemId !== 0) writer.tag(5, WireType.Varint).int32(message.systemId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.SecondarySun
 */
export const SecondarySun = new SecondarySun$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Star$Type extends MessageType<Star> {
    constructor() {
        super("eve_multitools.data.Star", [
            { no: 1, name: "star_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "statistics", kind: "message", T: () => Star_StarStatistics },
            {
                no: 5,
                name: "npc_stations",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 6, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<Star>): Star {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.starId = 0;
        message.radius = 0;
        message.typeId = 0;
        message.npcStations = [];
        message.systemId = 0;
        if (value !== undefined) reflectionMergePartial<Star>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Star
    ): Star {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 star_id */ 1:
                    message.starId = reader.int32();
                    break;
                case /* required double radius */ 2:
                    message.radius = reader.double();
                    break;
                case /* required int32 type_id */ 3:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.Star.StarStatistics statistics */ 4:
                    message.statistics = Star_StarStatistics.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.statistics
                    );
                    break;
                case /* repeated int32 npc_stations */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.npcStations.push(reader.int32());
                    else message.npcStations.push(reader.int32());
                    break;
                case /* required int32 system_id */ 6:
                    message.systemId = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Star,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 star_id = 1; */
        if (message.starId !== 0) writer.tag(1, WireType.Varint).int32(message.starId);
        /* required double radius = 2; */
        if (message.radius !== 0) writer.tag(2, WireType.Bit64).double(message.radius);
        /* required int32 type_id = 3; */
        if (message.typeId !== 0) writer.tag(3, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.Star.StarStatistics statistics = 4; */
        if (message.statistics)
            Star_StarStatistics.internalBinaryWrite(
                message.statistics,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* repeated int32 npc_stations = 5; */
        for (let i = 0; i < message.npcStations.length; i++)
            writer.tag(5, WireType.Varint).int32(message.npcStations[i]);
        /* required int32 system_id = 6; */
        if (message.systemId !== 0) writer.tag(6, WireType.Varint).int32(message.systemId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Star
 */
export const Star = new Star$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Star_StarStatistics$Type extends MessageType<Star_StarStatistics> {
    constructor() {
        super("eve_multitools.data.Star.StarStatistics", [
            { no: 1, name: "age", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "life", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "luminosity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "temperature", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "spectral_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
        ]);
    }
    create(value?: PartialMessage<Star_StarStatistics>): Star_StarStatistics {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.age = 0;
        message.life = 0;
        message.locked = false;
        message.luminosity = 0;
        message.radius = 0;
        message.temperature = 0;
        message.spectralClass = "";
        if (value !== undefined) reflectionMergePartial<Star_StarStatistics>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Star_StarStatistics
    ): Star_StarStatistics {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required double age */ 1:
                    message.age = reader.double();
                    break;
                case /* required double life */ 2:
                    message.life = reader.double();
                    break;
                case /* required bool locked */ 3:
                    message.locked = reader.bool();
                    break;
                case /* required double luminosity */ 4:
                    message.luminosity = reader.double();
                    break;
                case /* required double radius */ 5:
                    message.radius = reader.double();
                    break;
                case /* required double temperature */ 6:
                    message.temperature = reader.double();
                    break;
                case /* required string spectral_class */ 7:
                    message.spectralClass = reader.string();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Star_StarStatistics,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required double age = 1; */
        if (message.age !== 0) writer.tag(1, WireType.Bit64).double(message.age);
        /* required double life = 2; */
        if (message.life !== 0) writer.tag(2, WireType.Bit64).double(message.life);
        /* required bool locked = 3; */
        if (message.locked !== false) writer.tag(3, WireType.Varint).bool(message.locked);
        /* required double luminosity = 4; */
        if (message.luminosity !== 0) writer.tag(4, WireType.Bit64).double(message.luminosity);
        /* required double radius = 5; */
        if (message.radius !== 0) writer.tag(5, WireType.Bit64).double(message.radius);
        /* required double temperature = 6; */
        if (message.temperature !== 0) writer.tag(6, WireType.Bit64).double(message.temperature);
        /* required string spectral_class = 7; */
        if (message.spectralClass !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.spectralClass);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Star.StarStatistics
 */
export const Star_StarStatistics = new Star_StarStatistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stargate$Type extends MessageType<Stargate> {
    constructor() {
        super("eve_multitools.data.Stargate", [
            { no: 1, name: "stargate_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "destination", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "position", kind: "message", T: () => UniversePoint },
            { no: 4, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "rotation", kind: "message", T: () => Rotation },
            {
                no: 6,
                name: "ignored_by_corporation_defense_djinn",
                kind: "scalar",
                opt: true,
                T: 8 /*ScalarType.BOOL*/,
            },
            {
                no: 7,
                name: "allowed_ships_type_list_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 8, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "destination_system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<Stargate>): Stargate {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.stargateId = 0;
        message.destination = 0;
        message.typeId = 0;
        message.systemId = 0;
        message.destinationSystemId = 0;
        if (value !== undefined) reflectionMergePartial<Stargate>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Stargate
    ): Stargate {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 stargate_id */ 1:
                    message.stargateId = reader.int32();
                    break;
                case /* required int32 destination */ 2:
                    message.destination = reader.int32();
                    break;
                case /* required eve_multitools.data.UniversePoint position */ 3:
                    message.position = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.position
                    );
                    break;
                case /* required int32 type_id */ 4:
                    message.typeId = reader.int32();
                    break;
                case /* optional eve_multitools.data.Rotation rotation */ 5:
                    message.rotation = Rotation.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.rotation
                    );
                    break;
                case /* optional bool ignored_by_corporation_defense_djinn */ 6:
                    message.ignoredByCorporationDefenseDjinn = reader.bool();
                    break;
                case /* optional int32 allowed_ships_type_list_id */ 7:
                    message.allowedShipsTypeListId = reader.int32();
                    break;
                case /* required int32 system_id */ 8:
                    message.systemId = reader.int32();
                    break;
                case /* required int32 destination_system_id */ 9:
                    message.destinationSystemId = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Stargate,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 stargate_id = 1; */
        if (message.stargateId !== 0) writer.tag(1, WireType.Varint).int32(message.stargateId);
        /* required int32 destination = 2; */
        if (message.destination !== 0) writer.tag(2, WireType.Varint).int32(message.destination);
        /* required eve_multitools.data.UniversePoint position = 3; */
        if (message.position)
            UniversePoint.internalBinaryWrite(
                message.position,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required int32 type_id = 4; */
        if (message.typeId !== 0) writer.tag(4, WireType.Varint).int32(message.typeId);
        /* optional eve_multitools.data.Rotation rotation = 5; */
        if (message.rotation)
            Rotation.internalBinaryWrite(
                message.rotation,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* optional bool ignored_by_corporation_defense_djinn = 6; */
        if (message.ignoredByCorporationDefenseDjinn !== undefined)
            writer.tag(6, WireType.Varint).bool(message.ignoredByCorporationDefenseDjinn);
        /* optional int32 allowed_ships_type_list_id = 7; */
        if (message.allowedShipsTypeListId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.allowedShipsTypeListId);
        /* required int32 system_id = 8; */
        if (message.systemId !== 0) writer.tag(8, WireType.Varint).int32(message.systemId);
        /* required int32 destination_system_id = 9; */
        if (message.destinationSystemId !== 0)
            writer.tag(9, WireType.Varint).int32(message.destinationSystemId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Stargate
 */
export const Stargate = new Stargate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisruptedStargate$Type extends MessageType<DisruptedStargate> {
    constructor() {
        super("eve_multitools.data.DisruptedStargate", [
            { no: 1, name: "stargate_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "target_solar_system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "position", kind: "message", T: () => UniversePoint },
            { no: 5, name: "rotation", kind: "message", T: () => PointRotation },
            { no: 6, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<DisruptedStargate>): DisruptedStargate {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.stargateId = 0;
        message.typeId = 0;
        message.targetSolarSystemId = 0;
        message.systemId = 0;
        if (value !== undefined) reflectionMergePartial<DisruptedStargate>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: DisruptedStargate
    ): DisruptedStargate {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 stargate_id */ 1:
                    message.stargateId = reader.int32();
                    break;
                case /* required int32 type_id */ 2:
                    message.typeId = reader.int32();
                    break;
                case /* required int32 target_solar_system_id */ 3:
                    message.targetSolarSystemId = reader.int32();
                    break;
                case /* required eve_multitools.data.UniversePoint position */ 4:
                    message.position = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.position
                    );
                    break;
                case /* required eve_multitools.data.PointRotation rotation */ 5:
                    message.rotation = PointRotation.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.rotation
                    );
                    break;
                case /* required int32 system_id */ 6:
                    message.systemId = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: DisruptedStargate,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 stargate_id = 1; */
        if (message.stargateId !== 0) writer.tag(1, WireType.Varint).int32(message.stargateId);
        /* required int32 type_id = 2; */
        if (message.typeId !== 0) writer.tag(2, WireType.Varint).int32(message.typeId);
        /* required int32 target_solar_system_id = 3; */
        if (message.targetSolarSystemId !== 0)
            writer.tag(3, WireType.Varint).int32(message.targetSolarSystemId);
        /* required eve_multitools.data.UniversePoint position = 4; */
        if (message.position)
            UniversePoint.internalBinaryWrite(
                message.position,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required eve_multitools.data.PointRotation rotation = 5; */
        if (message.rotation)
            PointRotation.internalBinaryWrite(
                message.rotation,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required int32 system_id = 6; */
        if (message.systemId !== 0) writer.tag(6, WireType.Varint).int32(message.systemId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.DisruptedStargate
 */
export const DisruptedStargate = new DisruptedStargate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Moon$Type extends MessageType<Moon> {
    constructor() {
        super("eve_multitools.data.Moon", [
            { no: 1, name: "moon_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "attributes", kind: "message", T: () => CelestialAttributes },
            { no: 4, name: "position", kind: "message", T: () => UniversePoint },
            { no: 5, name: "radius", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "orbit_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "moon_name_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            {
                no: 8,
                name: "npc_stations",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 9, name: "statistics", kind: "message", T: () => CelestialStatistics },
            {
                no: 10,
                name: "asteroid_belts",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 11, name: "mining_beacon", kind: "message", T: () => Moon_MiningBeacon },
            {
                no: 12,
                name: "environment_template_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 13, name: "planet_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "celestial_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<Moon>): Moon {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.moonId = 0;
        message.typeId = 0;
        message.radius = 0;
        message.orbitId = 0;
        message.npcStations = [];
        message.asteroidBelts = [];
        message.planetId = 0;
        message.celestialIndex = 0;
        if (value !== undefined) reflectionMergePartial<Moon>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Moon
    ): Moon {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 moon_id */ 1:
                    message.moonId = reader.int32();
                    break;
                case /* required int32 type_id */ 2:
                    message.typeId = reader.int32();
                    break;
                case /* required eve_multitools.data.CelestialAttributes attributes */ 3:
                    message.attributes = CelestialAttributes.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.attributes
                    );
                    break;
                case /* required eve_multitools.data.UniversePoint position */ 4:
                    message.position = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.position
                    );
                    break;
                case /* required double radius */ 5:
                    message.radius = reader.double();
                    break;
                case /* required int32 orbit_id */ 6:
                    message.orbitId = reader.int32();
                    break;
                case /* optional int32 moon_name_id */ 7:
                    message.moonNameId = reader.int32();
                    break;
                case /* repeated int32 npc_stations */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.npcStations.push(reader.int32());
                    else message.npcStations.push(reader.int32());
                    break;
                case /* optional eve_multitools.data.CelestialStatistics statistics */ 9:
                    message.statistics = CelestialStatistics.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.statistics
                    );
                    break;
                case /* repeated int32 asteroid_belts */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e; )
                            message.asteroidBelts.push(reader.int32());
                    else message.asteroidBelts.push(reader.int32());
                    break;
                case /* optional eve_multitools.data.Moon.MiningBeacon mining_beacon */ 11:
                    message.miningBeacon = Moon_MiningBeacon.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.miningBeacon
                    );
                    break;
                case /* optional int32 environment_template_id */ 12:
                    message.environmentTemplateId = reader.int32();
                    break;
                case /* required int32 planet_id */ 13:
                    message.planetId = reader.int32();
                    break;
                case /* required int32 celestial_index */ 14:
                    message.celestialIndex = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Moon,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 moon_id = 1; */
        if (message.moonId !== 0) writer.tag(1, WireType.Varint).int32(message.moonId);
        /* required int32 type_id = 2; */
        if (message.typeId !== 0) writer.tag(2, WireType.Varint).int32(message.typeId);
        /* required eve_multitools.data.CelestialAttributes attributes = 3; */
        if (message.attributes)
            CelestialAttributes.internalBinaryWrite(
                message.attributes,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required eve_multitools.data.UniversePoint position = 4; */
        if (message.position)
            UniversePoint.internalBinaryWrite(
                message.position,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required double radius = 5; */
        if (message.radius !== 0) writer.tag(5, WireType.Bit64).double(message.radius);
        /* required int32 orbit_id = 6; */
        if (message.orbitId !== 0) writer.tag(6, WireType.Varint).int32(message.orbitId);
        /* optional int32 moon_name_id = 7; */
        if (message.moonNameId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.moonNameId);
        /* repeated int32 npc_stations = 8; */
        for (let i = 0; i < message.npcStations.length; i++)
            writer.tag(8, WireType.Varint).int32(message.npcStations[i]);
        /* optional eve_multitools.data.CelestialStatistics statistics = 9; */
        if (message.statistics)
            CelestialStatistics.internalBinaryWrite(
                message.statistics,
                writer.tag(9, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* repeated int32 asteroid_belts = 10; */
        for (let i = 0; i < message.asteroidBelts.length; i++)
            writer.tag(10, WireType.Varint).int32(message.asteroidBelts[i]);
        /* optional eve_multitools.data.Moon.MiningBeacon mining_beacon = 11; */
        if (message.miningBeacon)
            Moon_MiningBeacon.internalBinaryWrite(
                message.miningBeacon,
                writer.tag(11, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* optional int32 environment_template_id = 12; */
        if (message.environmentTemplateId !== undefined)
            writer.tag(12, WireType.Varint).int32(message.environmentTemplateId);
        /* required int32 planet_id = 13; */
        if (message.planetId !== 0) writer.tag(13, WireType.Varint).int32(message.planetId);
        /* required int32 celestial_index = 14; */
        if (message.celestialIndex !== 0)
            writer.tag(14, WireType.Varint).int32(message.celestialIndex);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Moon
 */
export const Moon = new Moon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Moon_MiningBeacon$Type extends MessageType<Moon_MiningBeacon> {
    constructor() {
        super("eve_multitools.data.Moon.MiningBeacon", [
            { no: 1, name: "position", kind: "message", T: () => UniversePoint },
        ]);
    }
    create(value?: PartialMessage<Moon_MiningBeacon>): Moon_MiningBeacon {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined) reflectionMergePartial<Moon_MiningBeacon>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Moon_MiningBeacon
    ): Moon_MiningBeacon {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required eve_multitools.data.UniversePoint position */ 1:
                    message.position = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.position
                    );
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: Moon_MiningBeacon,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required eve_multitools.data.UniversePoint position = 1; */
        if (message.position)
            UniversePoint.internalBinaryWrite(
                message.position,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.Moon.MiningBeacon
 */
export const Moon_MiningBeacon = new Moon_MiningBeacon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NpcStation$Type extends MessageType<NpcStation> {
    constructor() {
        super("eve_multitools.data.NpcStation", [
            { no: 1, name: "station_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "is_conquerable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "operation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "owner_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "position", kind: "message", T: () => UniversePoint },
            { no: 6, name: "reprocessing_efficiency", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "reprocessing_hangar_flag", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            {
                no: 8,
                name: "reprocessing_stations_take",
                kind: "scalar",
                T: 1 /*ScalarType.DOUBLE*/,
            },
            { no: 9, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "use_operation_name", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "orbit_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "graphic_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "solar_system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "rotation", kind: "message", T: () => Rotation },
            { no: 15, name: "station_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            {
                no: 16,
                name: "ignored_by_corporation_defense_djinn",
                kind: "scalar",
                opt: true,
                T: 8 /*ScalarType.BOOL*/,
            },
            { no: 17, name: "moon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "planet_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "star_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<NpcStation>): NpcStation {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.stationId = 0;
        message.isConquerable = false;
        message.operationId = 0;
        message.ownerId = 0;
        message.reprocessingEfficiency = 0;
        message.reprocessingHangarFlag = 0;
        message.reprocessingStationsTake = 0;
        message.typeId = 0;
        message.useOperationName = false;
        message.orbitId = 0;
        message.graphicId = 0;
        message.solarSystemId = 0;
        message.stationName = "";
        if (value !== undefined) reflectionMergePartial<NpcStation>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: NpcStation
    ): NpcStation {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 station_id */ 1:
                    message.stationId = reader.int32();
                    break;
                case /* required bool is_conquerable */ 2:
                    message.isConquerable = reader.bool();
                    break;
                case /* required int32 operation_id */ 3:
                    message.operationId = reader.int32();
                    break;
                case /* required int32 owner_id */ 4:
                    message.ownerId = reader.int32();
                    break;
                case /* required eve_multitools.data.UniversePoint position */ 5:
                    message.position = UniversePoint.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.position
                    );
                    break;
                case /* required double reprocessing_efficiency */ 6:
                    message.reprocessingEfficiency = reader.double();
                    break;
                case /* required int32 reprocessing_hangar_flag */ 7:
                    message.reprocessingHangarFlag = reader.int32();
                    break;
                case /* required double reprocessing_stations_take */ 8:
                    message.reprocessingStationsTake = reader.double();
                    break;
                case /* required int32 type_id */ 9:
                    message.typeId = reader.int32();
                    break;
                case /* required bool use_operation_name */ 10:
                    message.useOperationName = reader.bool();
                    break;
                case /* required int32 orbit_id */ 11:
                    message.orbitId = reader.int32();
                    break;
                case /* required int32 graphic_id */ 12:
                    message.graphicId = reader.int32();
                    break;
                case /* required int32 solar_system_id */ 13:
                    message.solarSystemId = reader.int32();
                    break;
                case /* optional eve_multitools.data.Rotation rotation */ 14:
                    message.rotation = Rotation.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.rotation
                    );
                    break;
                case /* required string station_name */ 15:
                    message.stationName = reader.string();
                    break;
                case /* optional bool ignored_by_corporation_defense_djinn */ 16:
                    message.ignoredByCorporationDefenseDjinn = reader.bool();
                    break;
                case /* optional int32 moon_id */ 17:
                    message.moonId = reader.int32();
                    break;
                case /* optional int32 planet_id */ 18:
                    message.planetId = reader.int32();
                    break;
                case /* optional int32 star_id */ 19:
                    message.starId = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: NpcStation,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 station_id = 1; */
        if (message.stationId !== 0) writer.tag(1, WireType.Varint).int32(message.stationId);
        /* required bool is_conquerable = 2; */
        if (message.isConquerable !== false)
            writer.tag(2, WireType.Varint).bool(message.isConquerable);
        /* required int32 operation_id = 3; */
        if (message.operationId !== 0) writer.tag(3, WireType.Varint).int32(message.operationId);
        /* required int32 owner_id = 4; */
        if (message.ownerId !== 0) writer.tag(4, WireType.Varint).int32(message.ownerId);
        /* required eve_multitools.data.UniversePoint position = 5; */
        if (message.position)
            UniversePoint.internalBinaryWrite(
                message.position,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required double reprocessing_efficiency = 6; */
        if (message.reprocessingEfficiency !== 0)
            writer.tag(6, WireType.Bit64).double(message.reprocessingEfficiency);
        /* required int32 reprocessing_hangar_flag = 7; */
        if (message.reprocessingHangarFlag !== 0)
            writer.tag(7, WireType.Varint).int32(message.reprocessingHangarFlag);
        /* required double reprocessing_stations_take = 8; */
        if (message.reprocessingStationsTake !== 0)
            writer.tag(8, WireType.Bit64).double(message.reprocessingStationsTake);
        /* required int32 type_id = 9; */
        if (message.typeId !== 0) writer.tag(9, WireType.Varint).int32(message.typeId);
        /* required bool use_operation_name = 10; */
        if (message.useOperationName !== false)
            writer.tag(10, WireType.Varint).bool(message.useOperationName);
        /* required int32 orbit_id = 11; */
        if (message.orbitId !== 0) writer.tag(11, WireType.Varint).int32(message.orbitId);
        /* required int32 graphic_id = 12; */
        if (message.graphicId !== 0) writer.tag(12, WireType.Varint).int32(message.graphicId);
        /* required int32 solar_system_id = 13; */
        if (message.solarSystemId !== 0)
            writer.tag(13, WireType.Varint).int32(message.solarSystemId);
        /* optional eve_multitools.data.Rotation rotation = 14; */
        if (message.rotation)
            Rotation.internalBinaryWrite(
                message.rotation,
                writer.tag(14, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* required string station_name = 15; */
        if (message.stationName !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.stationName);
        /* optional bool ignored_by_corporation_defense_djinn = 16; */
        if (message.ignoredByCorporationDefenseDjinn !== undefined)
            writer.tag(16, WireType.Varint).bool(message.ignoredByCorporationDefenseDjinn);
        /* optional int32 moon_id = 17; */
        if (message.moonId !== undefined) writer.tag(17, WireType.Varint).int32(message.moonId);
        /* optional int32 planet_id = 18; */
        if (message.planetId !== undefined) writer.tag(18, WireType.Varint).int32(message.planetId);
        /* optional int32 star_id = 19; */
        if (message.starId !== undefined) writer.tag(19, WireType.Varint).int32(message.starId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.NpcStation
 */
export const NpcStation = new NpcStation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsteroidBelt$Type extends MessageType<AsteroidBelt> {
    constructor() {
        super("eve_multitools.data.AsteroidBelt", [
            { no: 1, name: "asteroid_belt_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            {
                no: 3,
                name: "asteroid_belt_name_id",
                kind: "scalar",
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            { no: 4, name: "statistics", kind: "message", T: () => CelestialStatistics },
            { no: 5, name: "planet_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "moon_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
        ]);
    }
    create(value?: PartialMessage<AsteroidBelt>): AsteroidBelt {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.asteroidBeltId = 0;
        message.typeId = 0;
        if (value !== undefined) reflectionMergePartial<AsteroidBelt>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AsteroidBelt
    ): AsteroidBelt {
        const message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 asteroid_belt_id */ 1:
                    message.asteroidBeltId = reader.int32();
                    break;
                case /* required int32 type_id */ 2:
                    message.typeId = reader.int32();
                    break;
                case /* optional int32 asteroid_belt_name_id */ 3:
                    message.asteroidBeltNameId = reader.int32();
                    break;
                case /* optional eve_multitools.data.CelestialStatistics statistics */ 4:
                    message.statistics = CelestialStatistics.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.statistics
                    );
                    break;
                case /* optional int32 planet_id */ 5:
                    message.planetId = reader.int32();
                    break;
                case /* optional int32 moon_id */ 6:
                    message.moonId = reader.int32();
                    break;
                default: {
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
                }
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: AsteroidBelt,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* required int32 asteroid_belt_id = 1; */
        if (message.asteroidBeltId !== 0)
            writer.tag(1, WireType.Varint).int32(message.asteroidBeltId);
        /* required int32 type_id = 2; */
        if (message.typeId !== 0) writer.tag(2, WireType.Varint).int32(message.typeId);
        /* optional int32 asteroid_belt_name_id = 3; */
        if (message.asteroidBeltNameId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.asteroidBeltNameId);
        /* optional eve_multitools.data.CelestialStatistics statistics = 4; */
        if (message.statistics)
            CelestialStatistics.internalBinaryWrite(
                message.statistics,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* optional int32 planet_id = 5; */
        if (message.planetId !== undefined) writer.tag(5, WireType.Varint).int32(message.planetId);
        /* optional int32 moon_id = 6; */
        if (message.moonId !== undefined) writer.tag(6, WireType.Varint).int32(message.moonId);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_multitools.data.AsteroidBelt
 */
export const AsteroidBelt = new AsteroidBelt$Type();
