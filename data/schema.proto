syntax = "proto2";

package eve_multitools.data;

// Type ID definition
// This mirrors the structure of typeIDs.json in the FSD
message TypeID {
    required double base_price = 1;
    required double capacity = 2;
    optional int32 certificate_template = 3;
    optional int32 description_id = 4;
    repeated int32 designer_ids = 5;
    optional int32 faction_id = 6;
    optional int32 graphic_id = 7;
    required int32 group_id = 8;
    optional int32 icon_id = 9;
    required bool is_dynamic_type = 10;
    optional int32 isis_group_id = 11;
    optional int32 market_group_id = 12;
    optional int32 meta_group_id = 13;
    optional int32 meta_level = 14;
    required int32 portion_size = 15;
    required bool published = 16;
    optional int32 quote_author_id = 17;
    optional int32 quote_id = 18;
    optional int32 race_id = 19;
    required double radius = 20;
    optional int32 sound_id = 21;
    optional int32 tech_level = 22;
    required int32 type_id = 23;
    required int32 type_name_id = 24;
    optional int32 variation_parent_type_id = 25;
    required double volume = 26;
    optional int32 wreck_type_id = 27;
}

// Type dogma definition
// This mirrors the structure of typeDogma.json in the FSD
message TypeDogma {
    // Dogma attribute definition
    message DogmaAttribute {
        required int32 attribute_id = 1;
        required double value = 2;
    }
    
    // Dogma effect definition
    message DogmaEffect {
        required int32 effect_id = 1;
        required bool is_default = 2;
    }
    
    repeated DogmaAttribute dogma_attributes = 1;
    repeated DogmaEffect dogma_effects = 2;
}

// Type material definition
// This mirrors the structure of typeMaterials.json in the FSD
message TypeMaterial {
    // Material definition
    message Material {
        required int32 material_type_id = 1;
        required int32 quantity = 2;
    }
    
    repeated Material materials = 1;
}

// Collection of all type IDs
message TypeCollection {
    message TypeEntry {
        required int32 type_id = 1;
        required TypeID type_data = 2;
    }
    repeated TypeEntry types = 1;
}

// Collection of all type dogma data
message TypeDogmaCollection {
    message TypeDogmaEntry {
        required int32 type_id = 1;
        required TypeDogma type_dogma = 2;
    }
    repeated TypeDogmaEntry type_dogmas = 1;
}

// Collection of all type material data
message TypeMaterialCollection {
    message TypeMaterialEntry {
        required int32 type_id = 1;
        required TypeMaterial type_material = 2;
    }
    repeated TypeMaterialEntry type_materials = 1;
}

// Category definition
message Category {
    required int32 category_id = 1;
    required int32 category_name_id = 2;
    optional int32 icon_id = 3;
    required bool published = 4;
}

// Collection of all categories
message CategoryCollection {
    message CategoryEntry {
        required int32 category_id = 1;
        required Category category_data = 2;
    }
    repeated CategoryEntry categories = 1;
}

// Group definition
message Group {
    required int32 group_id = 1;
    required int32 group_name_id = 2;
    optional int32 icon_id = 3;
    required int32 category_id = 4;
    required bool anchorable = 5;
    required bool fittable_non_singleton = 6;
    required bool anchored = 7;
    required bool published = 8;
    required bool use_base_price = 9;
}

// Collection of all groups
message GroupCollection {
    message GroupEntry {
        required int32 group_id = 1;
        required Group group_data = 2;
    }
    repeated GroupEntry groups = 1;
}

// MetaGroup definition
message MetaGroup {
    required int32 name_id = 1;
    optional int32 icon_id = 2;
}

// Collection of all meta groups
message MetaGroupCollection {
    message MetaGroupEntry {
        required int32 meta_group_id = 1;
        required MetaGroup meta_group_data = 2;
    }
    repeated MetaGroupEntry meta_groups = 1;
}

// Localization string definition
message LocalizationString {
    required string en = 1;
    required string zh = 2;
}

// Collection of all localization strings
message LocalizationCollection {
    message LocalizationEntry {
        required uint32 key = 1;
        required LocalizationString localization_data = 2;
    }
    repeated LocalizationEntry localizations = 1;
}

// Type localization lookup data
message TypeLocalizationLookup {
    message TypeLocEntry {
        required int32 type_id = 1;
        required uint32 type_name_id = 2;
        optional uint32 type_description_id = 3;
    }
    repeated TypeLocEntry type_entries = 1;
}
